<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Aviator Learner ‚Äì Se√±ales (con filtros) + OCR + Live Capture</title>
<style>
  :root { --bg:#0f172a; --card:#0b1220; --muted:#94a3b8; --text:#e5e7eb; --accent:#60a5fa; --ok:#22c55e; --bad:#ef4444; }
  *{box-sizing:border-box} body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,Segoe UI,Inter,Roboto,Arial}
  .wrap{max-width:1100px;margin:0 auto;padding:20px}
  h1{margin:0 0 8px;font-size:22px} h2{margin:0 0 8px;font-size:18px}
  .card{background:var(--card);border:1px solid #1f2937;border-radius:14px;padding:14px;margin-top:12px}
  .row{display:grid;grid-template-columns:1fr;gap:12px}
  @media(min-width:980px){ .row2{grid-template-columns:2fr 1fr} }
  textarea,input,select,button{border-radius:10px;border:1px solid #334155;background:#0b1220;color:var(--text)}
  textarea{width:100%;min-height:90px;padding:8px}
  input,select{padding:8px;width:100%}
  .btn{padding:8px 12px;background:#111827;border:1px solid #334155;cursor:pointer;border-radius:10px}
  .btn:hover{border-color:#475569}
  .muted{color:var(--muted);font-size:13px}
  .rowflex{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .pill{padding:2px 8px;border:1px solid #334155;border-radius:999px;font-size:12px}
  .signal{font-weight:700} .ok{color:var(--ok)} .no{color:var(--bad)}
  .small{font-size:12px}
  .kbd{border:1px solid #334155;border-radius:6px;padding:0 6px;font-size:12px;color:#cbd5e1}
  .table{width:100%;border-collapse:collapse;font-size:13px}
  .table td,.table th{border-bottom:1px solid #1f2937;padding:6px 4px;text-align:left}
  canvas{width:100%;height:280px;background:#0a0f1f;border:1px solid #1f2937;border-radius:12px}
</style>
</head>
<body>
<div class="wrap">
  <h1>üß™ Aviator Learner <span class="pill">online ¬∑ educativo ¬∑ sin autobet</span></h1>
  <div class="card">
    <p class="muted">Aprende en vivo con tus rondas y estima la probabilidad de que la <b>pr√≥xima</b> sea ‚â• <b>target</b>. No garantiza resultados ni interact√∫a con el sitio.</p>
  </div>

  <div class="row row2">
    <div>
      <div class="card">
        <h2>Entrada de rondas</h2>
        <textarea id="ta" placeholder="Pega multiplicadores: 1.2 2.4 8.3 145 1.1 ..."></textarea>
        <div class="rowflex">
          <button class="btn" id="btnAdd">A√±adir</button>
          <button class="btn" id="btnClear">Limpiar</button>
          <label class="btn"><input type="file" id="file" accept=".csv,.txt" hidden>Importar CSV/TXT</label>
        </div>
        <div class="rowflex" style="margin-top:6px">
          <input id="quick" placeholder="R√°pido: 123 => 1.23" style="width:160px">
          <button class="btn" id="btnQuick">A√±adir r√°pido</button>
          <span class="muted">Enter tambi√©n a√±ade.</span>
        </div>
        <div class="card" style="margin-top:10px">
          <h2>üìã Portapapeles</h2>
          <div class="rowflex">
            <label><input type="checkbox" id="cbClip"> Auto-lectura</label>
            <label>Intervalo (ms) <input type="number" id="clipMS" value="800" style="width:90px"></label>
            <button class="btn" id="btnClipOnce">Leer una vez (<span class="kbd">V</span>)</button>
          </div>
          <p class="muted">En la otra pesta√±a selecciona el n√∫mero y pulsa <b>Ctrl+C</b>. Aqu√≠ se a√±adir√° si es v√°lido.</p>
          <div class="muted" id="clipStatus"></div>
        </div>
      </div>

      <div class="card">
        <h2>OCR de captura (√∫ltimas ~60 rondas)</h2>
        <div class="rowflex">
          <label class="btn"><input type="file" id="imgFile" accept="image/*" hidden>Subir captura</label>
          <label><input type="checkbox" id="chkReverse"> Invertir orden extra√≠do</label>
          <button class="btn" id="btnOCR">Procesar OCR</button>
        </div>
        <div class="muted small">Usa capturas n√≠tidas; el OCR detecta formatos como <code>1.23x</code> o <code>1.23</code>.
          Si tu captura viene de ‚Äúm√°s reciente ‚Üí m√°s antiguo‚Äù, marca ‚ÄúInvertir‚Äù.</div>
        <div id="ocrStatus" class="muted small"></div>
      </div>

      <!-- NUEVO: Captura en tiempo real -->
      <div class="card">
        <h2>Captura en tiempo real (compartir pantalla)</h2>
        <div class="rowflex">
          <button class="btn" id="liveStart">Iniciar captura</button>
          <button class="btn" id="liveStop">Detener</button>
          <label><input type="checkbox" id="liveAutoAdd" checked> Auto-agregar tras OCR</label>
          <label>FPS <input id="liveFps" type="number" value="3" style="width:80px"></label>
        </div>
        <div class="rowflex" style="margin-top:6px">
          <button class="btn" id="roiMode">Definir ROI</button>
          <label>Umbral rojo (%) <input id="redPct" type="number" step="1" value="25" style="width:80px"></label>
          <label>Estabilidad (frames) <input id="stableN" type="number" value="2" style="width:80px"></label>
          <label>Cooldown (s) <input id="liveCooldown" type="number" value="2" style="width:80px"></label>
        </div>
        <div class="muted small">
          1) Pulsa <b>Iniciar captura</b> y elige la pesta√±a del juego.<br>
          2) Pulsa <b>Definir ROI</b> y arrastra un rect√°ngulo alrededor del n√∫mero rojo final.<br>
          3) Cuando el n√∫mero se ponga rojo y estable, el bot har√° OCR y (si est√° marcado) lo agregar√°.
        </div>
        <div class="rowflex" style="gap:12px;align-items:flex-start;margin-top:8px">
          <div>
            <canvas id="liveCanvas" width="560" height="315" style="max-width:100%;border:1px solid #1f2937;border-radius:12px"></canvas>
            <div class="muted small" id="liveInfo">Sin captura</div>
          </div>
          <div style="flex:1">
            <div class="muted small" id="roiInfo">ROI: sin definir</div>
            <div class="muted small" id="liveLog" style="max-height:180px;overflow:auto;border:1px solid #1f2937;border-radius:8px;padding:6px"></div>
          </div>
        </div>
      </div>

      <div class="card">
        <h2>Modelo online (SGD) + filtros de se√±al</h2>
        <div class="rowflex">
          <label>Target ‚â• <input id="inpTarget" type="number" step="0.1" value="3" style="width:80px"></label>
          <label>Umbral p‚â• <input id="inpThresh" type="number" step="0.01" value="0.80" style="width:80px"></label>
          <label>Hist. m√≠nimo N<input id="inpMinN" type="number" value="10" style="width:80px"></label>
          <label>Ventana W<input id="inpW" type="number" value="40" style="width:80px"></label>
          <label>LR Œ±<input id="inpLR" type="number" step="0.001" value="0.02" style="width:80px"></label>
          <label>L2 Œª<input id="inpL2" type="number" step="0.0001" value="0.001" style="width:90px"></label>
        </div>

        <div class="rowflex" style="margin-top:6px">
          <label>Cooldown (rondas) <input id="gateCooldown" type="number" value="8" style="width:80px"></label>
          <label>W_low <input id="gateWlow" type="number" value="20" style="width:80px"></label>
          <label>Œº_min <input id="gateMuMin" type="number" step="0.01" value="1.30" style="width:80px"></label>
          <label>K d√©biles <input id="gateK" type="number" value="8" style="width:80px"></label>
          <label>Debil < L <input id="gateL" type="number" step="0.01" value="1.30" style="width:80px"></label>
          <label>M√°x d√©biles M <input id="gateM" type="number" value="3" style="width:80px"></label>
        </div>
        <div class="rowflex" style="margin-top:6px">
          <label>Bloquear si Bajista <input id="gateBlockBear" type="checkbox" checked></label>
          <label>T (temperatura) <input id="gateT" type="number" step="0.1" value="1.8" style="width:80px"></label>
          <label>Umbral adaptativo <input id="gateAdaptive" type="checkbox"></label>
          <label>Precisi√≥n objetivo <input id="gateTargetAcc" type="number" step="0.01" value="0.65" style="width:80px"></label>
        </div>

        <div class="rowflex" style="margin-top:6px">
          <button class="btn" id="btnReset">Reiniciar modelo</button>
          <button class="btn" id="btnExportModel">Exportar modelo</button>
          <label class="btn"><input type="file" id="fileModel" accept=".json" hidden>Importar modelo</label>
        </div>
        <div style="margin-top:8px">
          <div>Prob. estimada pr√≥xima ‚â• target: <span id="prob" class="signal">‚Äî</span></div>
          <div>Se√±al: <span id="signal" class="signal no">‚Äî</span></div>
          <div class="muted small">La se√±al solo sale si se cumplen <b>p‚â•umbral</b> y los filtros (cooldown, tendencia, media, d√©biles, temperatura).</div>
        </div>
      </div>
    </div>

    <div>
      <div class="card">
        <h2>Estad√≠sticas</h2>
        <table class="table small">
          <tr><th>N (rondas)</th><td id="stN">0</td></tr>
          <tr><th>Media</th><td id="stMean">0.00√ó</td></tr>
          <tr><th>Mediana</th><td id="stMed">0.00√ó</td></tr>
          <tr><th>P(‚â•3√ó)</th><td id="stP3">0.0%</td></tr>
          <tr><th>P(‚â•5√ó)</th><td id="stP5">0.0%</td></tr>
          <tr><th>M√°x</th><td id="stMax">0.00√ó</td></tr>
          <tr><th>Tendencia</th><td id="stTrend">‚Äî</td></tr>
        </table>
      </div>

      <div class="card">
        <h2>Se√±ales</h2>
        <table class="table small">
          <tr><th>Pendiente abierta</th><td id="sgPending">No</td></tr>
          <tr><th>Total se√±ales</th><td id="sgTotal">0</td></tr>
          <tr><th>Ganadas</th><td id="sgWins">0</td></tr>
          <tr><th>Perdidas</th><td id="sgLoss">0</td></tr>
          <tr><th>Precisi√≥n</th><td id="sgAcc">0.0%</td></tr>
        </table>
      </div>
    </div>
  </div>

  <div class="card">
    <div class="rowflex" style="justify-content:space-between;gap:12px">
      <h2>Gr√°fica (cap 200√ó) + Tendencia (√∫ltima ventana)</h2>
      <div class="rowflex">
        <label>Ventana tendencia (W) <input id="trW" type="number" value="40" style="width:90px"></label>
        <label>Umbral pendiente <input id="trEps" type="number" step="0.001" value="0.01" style="width:90px"></label>
        <button class="btn" id="btnReplot">Recalcular</button>
      </div>
    </div>
    <canvas id="chart" width="1080" height="280"></canvas>
  </div>

  <div class="card">
    <p class="muted small">Descargo: herramienta educativa. No es asesor√≠a financiera ni de apuestas.</p>
  </div>
</div>

<script>
/* ===== Utilidades ===== */
const $ = (id)=>document.getElementById(id);
function parseList(s){ if(!s) return []; return s.split(/[\s,;]+/).map(t=>t.trim()).filter(Boolean).map(Number).filter(x=>isFinite(x)&&x>0); }
function median(a){ if(!a.length) return 0; const s=[...a].sort((x,y)=>x-y); const m=Math.floor(s.length/2); return s.length%2?s[m]:(s[m-1]+s[m])/2; }
function stats(arr){
  const n=arr.length; if(!n) return {n:0,mean:0,med:0,max:0,p3:0,p5:0};
  const sum=arr.reduce((a,b)=>a+b,0), mean=sum/n, med=median(arr), max=Math.max(...arr);
  const p=(t)=>arr.filter(x=>x>=t).length/n;
  return {n,mean,med,max,p3:p(3),p5:p(5)};
}
function last(arr,k){ return arr.slice(Math.max(0,arr.length-k)); }
function clampSeries(data,cap=200){ return data.map((v,i)=>({i:i+1,m:Math.min(v,cap),real:v})); }
function quickNorm(s){
  s=(s||"").trim();
  if(!s) return null;
  if(!s.includes(".") && /^\d{2,4}$/.test(s)){
    if(s.length===2) s = s[0]+"."+s[1];
    else if(s.length===3) s = s[0]+"."+s.slice(1);
    else if(s.length===4) s = s.slice(0,2)+"."+s.slice(2);
  }
  const v=parseFloat(s.replace(',','.')); return (isFinite(v)&&v>0)?v:null;
}

/* ===== Helpers de filtros ===== */
function movingMean(arr, w){
  if(w<=0 || arr.length<w) return null;
  let s=0; for(let i=arr.length-w;i<arr.length;i++) s+=arr[i];
  return s/w;
}
function countBelow(arr, k, L){
  const lastK = arr.slice(Math.max(0, arr.length-k));
  return lastK.filter(v=>v < L).length;
}
function logit(p){ return Math.log(Math.max(1e-9, p) / Math.max(1e-9, 1-p)); }
function sigmoid(z){ return 1/(1+Math.exp(-z)); }

/* ===== OCR worker compartido (upload + live) ===== */
let TESSERACT_WORKER = null;
async function ensureTesseract(){
  if(TESSERACT_WORKER) return TESSERACT_WORKER;
  const { createWorker } = await import("https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.esm.min.js");
  TESSERACT_WORKER = await createWorker("eng");
  return TESSERACT_WORKER;
}

/* ===== Rasgos y modelo ===== */
function featuresFrom(history, W, target){
  const H = last(history, W);
  const n = H.length;
  const caps = H.map(v=>Math.min(v, 50));
  const logs = caps.map(v=>Math.log(1+v));
  const mean = caps.reduce((a,b)=>a+b,0)/(n||1);
  const meanLog = logs.reduce((a,b)=>a+b,0)/(n||1);
  const med = median(caps);
  const std = Math.sqrt((caps.reduce((a,b)=>a+(b-mean)**2,0)/(n||1))||0);
  const p3 = caps.filter(v=>v>=3).length/(n||1);
  const p5 = caps.filter(v=>v>=5).length/(n||1);
  let up=0, down=0;
  for(let i=caps.length-1;i>=0;i--){
    if(caps[i]>=target){ up++; if(down===0){} else break; }
    else { down++; if(up===0){} else break; }
  }
  const L = last(caps,5); while(L.length<5) L.unshift(0);
  let sinceHi=0; for(let i=caps.length-1;i>=0;i--){ if(caps[i]>=target) break; sinceHi++; }
  return [1, mean, med, std, meanLog, p3, p5, up, down, sinceHi, ...L];
}
class OnlineLogReg {
  constructor(d, lr=0.02, l2=0.001){ this.w=new Array(d).fill(0); this.lr=lr; this.l2=l2; this.prevX=null; this.prevP=null; }
  static sigmoid(z){ return 1/(1+Math.exp(-Math.max(-50,Math.min(50,z)))); }
  predict(x){ let z=0; for(let i=0;i<this.w.length;i++) z+=this.w[i]*x[i]; return OnlineLogReg.sigmoid(z); }
  stepPrepare(x){ const p=this.predict(x); this.prevX=x.slice(); this.prevP=p; return p; }
  update(y){ if(!this.prevX || this.prevP==null) return; const x=this.prevX, p=this.prevP; const g=p-y; for(let i=0;i<this.w.length;i++){ const grad=g*x[i]+this.l2*this.w[i]; this.w[i]-=this.lr*grad; } this.prevX=null; this.prevP=null; }
  export(){ return {w:this.w,lr:this.lr,l2:this.l2}; }
  import(o){ this.w=o.w.slice(); this.lr=o.lr; this.l2=o.l2; this.prevX=null; this.prevP=null; }
}
function modelDim(){ return 1 + 4 + 2 + 3 + 5; } // =15

/* ===== Tendencia ===== */
function linRegSlope(arr){
  const n=arr.length; if(n<2) return 0;
  const xMean=(n-1)/2; const yMean=arr.reduce((a,b)=>a+b,0)/n;
  let num=0, den=0; for(let i=0;i<n;i++){ const dx=i-xMean; num+=dx*(arr[i]-yMean); den+=dx*dx; }
  return den? num/den : 0;
}
function trendLabel(arr, W, eps){
  const w = Math.min(W, arr.length);
  if(w<2) return {txt:"‚Äî", slope:0};
  const slice = arr.slice(arr.length-w);
  const slope = linRegSlope(slice);
  const txt = slope > eps ? "Alcista" : (slope < -eps ? "Bajista" : "Lateral");
  return {txt, slope};
}

/* ===== Estado ===== */
let DATA=[];
let MODEL=null;
let SIGNAL_PENDING=false;
let SG_TOTAL=0, SG_WINS=0, SG_LOSS=0;
let LAST_SIGNAL_INDEX = -999999;

function ensureModel(){
  const lr = parseFloat($("inpLR").value)||0.02;
  const l2 = parseFloat($("inpL2").value)||0.001;
  if(!MODEL) MODEL = new OnlineLogReg(modelDim(), lr, l2);
  MODEL.lr=lr; MODEL.l2=l2;
}

/* ===== Se√±ales ===== */
function updateSignalCountersOnNewValue(value){
  const target = parseFloat($("inpTarget").value)||3;
  if(SIGNAL_PENDING){
    if(value >= target) SG_WINS++; else SG_LOSS++;
    SIGNAL_PENDING=false;
  }
  SG_TOTAL = SG_WINS + SG_LOSS;
  const acc = SG_TOTAL ? (SG_WINS/SG_TOTAL*100).toFixed(1)+"%" : "0.0%";
  $("sgPending").textContent = SIGNAL_PENDING ? "S√≠" : "No";
  $("sgTotal").textContent = SG_TOTAL;
  $("sgWins").textContent = SG_WINS;
  $("sgLoss").textContent = SG_LOSS;
  $("sgAcc").textContent = acc;
}

/* ===== Stats y gr√°fico ===== */
function renderStats(){
  const s=stats(DATA);
  $("stN").textContent = s.n;
  $("stMean").textContent = s.mean.toFixed(2)+"√ó";
  $("stMed").textContent = s.med.toFixed(2)+"√ó";
  $("stP3").textContent = (s.p3*100).toFixed(1)+"%";
  $("stP5").textContent = (s.p5*100).toFixed(1)+"%";
  $("stMax").textContent = s.max.toFixed(2)+"√ó";

  const trW = parseInt($("trW").value||"40",10);
  const trEps = parseFloat($("trEps").value||"0.01");
  const tr = trendLabel(DATA.map(v=>Math.min(v,50)), trW, trEps);
  $("stTrend").textContent = tr.txt;
}
function drawChart(){
  const c=$("chart"), ctx=c.getContext("2d");
  ctx.clearRect(0,0,c.width,c.height);
  if(!DATA.length){ ctx.fillStyle="#64748b"; ctx.fillText("Carga datos para ver la serie",10,20); return; }

  const cap=200, s=clampSeries(DATA,cap);
  const pad=30, w=c.width-pad*2, h=c.height-pad*2;
  const max=cap, min=0;

  // axes
  ctx.strokeStyle="#13203a"; ctx.beginPath();
  ctx.moveTo(pad,c.height-pad); ctx.lineTo(pad,pad); ctx.lineTo(c.width-pad,pad); ctx.stroke();

  // line
  ctx.strokeStyle="#cbd5e1"; ctx.beginPath();
  for(let i=0;i<s.length;i++){
    const x=pad + (i/(s.length-1))*w;
    const y=c.height - pad - ((s[i].m-min)/(max-min))*h;
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.stroke();

  // trend line (√∫ltima ventana)
  const trW = parseInt($("trW").value||"40",10);
  const wlen = Math.min(trW, s.length);
  if(wlen>=2){
    const arr = s.slice(s.length-wlen).map(o=>o.m);
    const xMean=(wlen-1)/2;
    const yMean=arr.reduce((a,b)=>a+b,0)/wlen;
    let num=0, den=0;
    for(let i=0;i<wlen;i++){ const dx=i-xMean; num += dx*(arr[i]-yMean); den += dx*dx; }
    const b = den? num/den : 0;
    const a = yMean - b*xMean;

    ctx.strokeStyle="#60a5fa"; ctx.beginPath();
    for(let i=0;i<wlen;i++){
      const xi = s.length - wlen + i;
      const x = pad + (xi/(s.length-1))*w;
      const yVal = a + b*i;
      const y = c.height - pad - ((yVal-min)/(max-min))*h;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
  }

  // target line
  const target=parseFloat($("inpTarget").value)||3;
  const yT = c.height - pad - ( (target-min)/(max-min) )*h;
  ctx.setLineDash([5,5]); ctx.strokeStyle="#3b82f6"; ctx.beginPath(); ctx.moveTo(pad,yT); ctx.lineTo(c.width-pad,yT); ctx.stroke(); ctx.setLineDash([]);
}

/* ===== Decisi√≥n de se√±al (con filtros) ===== */
function updatePredictionUI(pRaw){
  const thBase = parseFloat($("inpThresh").value)||0.8;
  const T = Math.max(0.5, parseFloat($("gateT").value)||1.0);
  const p = (pRaw==null)? null : sigmoid( logit(pRaw) / T );

  if(p==null){
    $("prob").textContent="‚Äî";
    $("signal").textContent="‚Äî";
    $("signal").className="signal no";
    $("sgPending").textContent = SIGNAL_PENDING ? "S√≠" : "No";
    return;
  }
  $("prob").textContent = p.toFixed(3);

  // Gates
  const cooldown = parseInt($("gateCooldown").value||"0",10);
  const idx = DATA.length;
  const cooldownOk = (idx - LAST_SIGNAL_INDEX) >= cooldown;

  const Wlow = parseInt($("gateWlow").value||"20",10);
  const muMin = parseFloat($("gateMuMin").value)||1.25;
  const mu = movingMean(DATA, Wlow);
  const meanOk = (mu===null) ? false : (mu >= muMin);

  const K = parseInt($("gateK").value||"8",10);
  const L = parseFloat($("gateL").value)||1.30;
  const M = parseInt($("gateM").value||"3",10);
  const weakCount = countBelow(DATA, K, L);
  const weakOk = weakCount <= M;

  const trW = parseInt($("trW").value||"40",10);
  const trEps = parseFloat($("trEps").value||"0.01");
  const tr = trendLabel(DATA.map(v=>Math.min(v,50)), trW, trEps);
  const blockBear = $("gateBlockBear").checked;
  const bearOk = (!blockBear) || (tr.txt !== "Bajista");

  // Umbral adaptativo
  let th = thBase;
  if ($("gateAdaptive").checked) {
    const targetAcc = parseFloat($("gateTargetAcc").value)||0.65;
    const acc = SG_TOTAL ? (SG_WINS/SG_TOTAL) : 0.0;
    if (acc < targetAcc) th = Math.min(0.99, thBase + 0.05);
    else if (acc > targetAcc + 0.1) th = Math.max(0.50, thBase - 0.02);
  }

  const passProb = p >= th;
  const allOk = passProb && cooldownOk && meanOk && weakOk && bearOk;

  if(allOk){
    $("signal").textContent = `SE√ëAL (p‚â•${th.toFixed(2)})`;
    $("signal").className="signal ok";
    SIGNAL_PENDING = true;
    LAST_SIGNAL_INDEX = idx;
  } else {
    $("signal").textContent = "No se√±al";
    $("signal").className="signal no";
  }
  $("sgPending").textContent = SIGNAL_PENDING ? "S√≠" : "No";
}

/* ===== Preparar predicci√≥n ===== */
function maybePredictNext(){
  const target = parseFloat($("inpTarget").value)||3;
  const W = parseInt($("inpW").value||"40",10);
  const minN = parseInt($("inpMinN").value||"10",10);
  ensureModel();
  let p = null;
  if(DATA.length>=Math.max(5,minN)){
    const x = featuresFrom(DATA, W, target);
    p = MODEL.stepPrepare(x);
  }
  updatePredictionUI(p);
}

/* ===== Nueva ronda ===== */
function onNewRound(value){
  const target = parseFloat($("inpTarget").value)||3;
  if(MODEL && MODEL.prevX){ const y = (value>=target)?1:0; MODEL.update(y); }
  updateSignalCountersOnNewValue(value);
  DATA.push(value);
  renderStats(); drawChart(); maybePredictNext();
}

/* ===== Eventos ===== */
$("btnAdd").onclick = ()=>{ const v=parseList($("ta").value); if(!v.length) return; v.forEach(onNewRound); $("ta").value=""; };
$("btnClear").onclick = ()=>{ DATA=[]; SIGNAL_PENDING=false; SG_TOTAL=SG_WINS=SG_LOSS=0;
  if(MODEL){ MODEL.prevX=null; MODEL.prevP=null; } renderStats(); drawChart(); updatePredictionUI(null);
  $("sgPending").textContent="No"; $("sgTotal").textContent="0"; $("sgWins").textContent="0"; $("sgLoss").textContent="0"; $("sgAcc").textContent="0.0%";
};
$("file").onchange = (e)=>{ const f=e.target.files?.[0]; if(!f) return; f.text().then(t=>{ const v=parseList(t); v.forEach(onNewRound); }); };
$("btnQuick").onclick = ()=>{ const v=quickNorm($("quick").value); if(v!=null){ onNewRound(v); $("quick").value=""; } };
$("quick").addEventListener("keydown",(ev)=>{ if(ev.key==="Enter"){ $("btnQuick").click(); }});
["inpThresh","gateCooldown","gateWlow","gateMuMin","gateK","gateL","gateM","gateBlockBear","gateT","gateAdaptive","gateTargetAcc","trW","trEps"].forEach(id=>{
  const el=$(id); el&&el.addEventListener("input", ()=> updatePredictionUI(MODEL?.prevP ?? null));
});

/* Modelo: reset/export/import */
$("btnReset").onclick = ()=>{ MODEL=null; ensureModel(); MODEL.prevX=null; MODEL.prevP=null; maybePredictNext(); };
$("btnExportModel").onclick = ()=>{
  ensureModel();
  const blob = new Blob([JSON.stringify(MODEL.export(),null,2)],{type:"application/json"});
  const url=URL.createObjectURL(blob); const a=document.createElement("a"); a.href=url; a.download="learner_model.json"; a.click(); URL.revokeObjectURL(url);
};
$("fileModel").onchange = (e)=>{ const f=e.target.files?.[0]; if(!f) return; f.text().then(t=>{ try{ const obj=JSON.parse(t); ensureModel(); MODEL.import(obj); alert("Modelo importado."); maybePredictNext(); }catch(_){ alert("JSON inv√°lido"); } }); };

/* Portapapeles */
let CLIP_TIMER=null, LAST_CLIP="";
function parseClip(t){ if(!t) return null; const s=t.trim().replace(',','.').toLowerCase(); const m=s.match(/(\d+(\.\d+)?)(\s*x)?$/i); if(!m) return null; const v=parseFloat(m[1]); return (isFinite(v)&&v>0)?v:null; }
async function readClipboardOnce(){
  try{
    const text = await navigator.clipboard.readText();
    $("clipStatus").textContent = 'Clip: "'+text.slice(0,50)+'"';
    const v = parseClip(text); if(v==null) return;
    const key=v.toFixed(6); if(key===LAST_CLIP) return; LAST_CLIP=key;
    onNewRound(v);
  }catch(e){ $("clipStatus").textContent="Permite acceso al portapapeles (HTTPS)."; }
}
$("cbClip").addEventListener("change",(e)=>{ if(e.target.checked){ const ms=Math.max(250,parseInt($("clipMS").value||"800",10)); if(CLIP_TIMER) clearInterval(CLIP_TIMER); CLIP_TIMER=setInterval(readClipboardOnce,ms); $("clipStatus").textContent="Auto-lectura cada "+ms+" ms."; } else { if(CLIP_TIMER) clearInterval(CLIP_TIMER); CLIP_TIMER=null; $("clipStatus").textContent="Auto-lectura desactivada."; }});
$("clipMS").addEventListener("input",()=>{ if($("cbClip").checked){ $("cbClip").dispatchEvent(new Event("change")); }});
$("btnClipOnce").onclick = readClipboardOnce;
window.addEventListener("keydown",(ev)=>{ if(ev.key.toLowerCase()==="v") readClipboardOnce(); });

/* OCR por imagen (usa worker compartido) */
let OCR_IMG_FILE=null;
$("imgFile").onchange = (e)=>{ OCR_IMG_FILE = e.target.files?.[0]||null; $("ocrStatus").textContent = OCR_IMG_FILE? ("Imagen: "+OCR_IMG_FILE.name) : "Sin imagen"; };
$("btnOCR").onclick = async ()=>{
  if(!OCR_IMG_FILE){ alert("Sube una captura primero."); return; }
  $("ocrStatus").textContent = "Cargando OCR...";
  try{
    const worker = await ensureTesseract();
    $("ocrStatus").textContent = "Leyendo texto‚Ä¶";
    const arrBuf = await OCR_IMG_FILE.arrayBuffer();
    const { data:{ text } } = await worker.recognize(arrBuf);
    $("ocrStatus").textContent = "Procesando resultados‚Ä¶";
    const raw = (text||"").replace(/,/g,".").toLowerCase();
    const matches = raw.match(/(\d+(\.\d+)?)(\s*x)?/g) || [];
    let nums = matches.map(s=>{ const m = s.match(/(\d+(\.\d+)?)/); return m? parseFloat(m[1]) : null; })
                      .filter(v=>v && isFinite(v) && v>0 && v<10000);
    if($("chkReverse").checked) nums.reverse();
    const before = DATA.length;
    nums.forEach(onNewRound);
    $("ocrStatus").textContent = `OCR listo. Extra√≠dos: ${nums.length}. A√±adidos: ${DATA.length-before}.`;
  }catch(err){
    console.error(err); $("ocrStatus").textContent = "Error OCR. Prueba otra captura (n√≠tida, contraste alto).";
  }
};

/* === Live Capture (pantalla) + rojo + OCR === */
let LIVE = { stream:null, video:null, ctx:null, canvas:null, running:false, roi:null, roiMode:false, redStable:0, lastGrabTs:0 };
function liveLog(msg){ const el=$("liveLog"); const li=document.createElement("div"); li.textContent = "["+(new Date()).toLocaleTimeString()+"] "+msg; el.prepend(li); }
function pxRedRatio(imgData){
  const d = imgData.data; let red=0, total=0;
  for(let i=0;i<d.length;i+=4){ const r=d[i], g=d[i+1], b=d[i+2], a=d[i+3]; if(a<10) continue; if(r>120 && r>g*1.25 && r>b*1.25) red++; total++; }
  return total? (red/total*100) : 0;
}
function drawROI(){ if(!LIVE.roi) return; const ctx = LIVE.ctx; ctx.save(); ctx.strokeStyle="#60a5fa"; ctx.setLineDash([6,4]); ctx.lineWidth=2; ctx.strokeRect(LIVE.roi.x, LIVE.roi.y, LIVE.roi.w, LIVE.roi.h); ctx.restore(); }
function setROIFromDrag(start, end){ const x=Math.min(start.x,end.x), y=Math.min(start.y,end.y); const w=Math.abs(end.x-start.x), h=Math.abs(end.y-start.y); if(w<10||h<10){ $("roiInfo").textContent="ROI: muy peque√±o"; return; } LIVE.roi={x,y,w,h}; $("roiInfo").textContent=`ROI: x=${x}, y=${y}, w=${w}, h=${h}`; }
async function ocrFromROI(){ if(!LIVE.roi) return null; const {x,y,w,h}=LIVE.roi; const tmp=document.createElement("canvas"); tmp.width=w; tmp.height=h; const tctx=tmp.getContext("2d"); tctx.drawImage($("liveCanvas"), x,y,w,h, 0,0,w,h); const buf=tmp.toDataURL("image/png"); const worker=await ensureTesseract(); const { data:{ text } } = await worker.recognize(buf); const raw=(text||"").replace(/,/g,".").toLowerCase(); const m=raw.match(/(\d+(\.\d+)?)/); if(!m) return null; const v=parseFloat(m[1]); if(!isFinite(v)||v<=0||v>10000) return null; return v; }
async function liveLoop(){
  if(!LIVE.running) return;
  const fps = Math.max(1, parseInt($("liveFps").value||"3",10));
  const delay = Math.round(1000/fps);
  const c=$("liveCanvas"), ctx=c.getContext("2d");
  const vw = LIVE.video.videoWidth || c.width; const vh = LIVE.video.videoHeight || c.height;
  if(c.width!==vw || c.height!==vh){ c.width=vw; c.height=vh; }
  ctx.drawImage(LIVE.video,0,0,c.width,c.height);
  drawROI();
  if(LIVE.roi){
    const {x,y,w,h}=LIVE.roi; const img = ctx.getImageData(x,y,w,h); const redPct = pxRedRatio(img);
    const thr = Math.max(1, parseFloat($("redPct").value)||25);
    const stableN = Math.max(1, parseInt($("stableN").value||"2",10));
    const cooldownMs = Math.max(0, parseInt($("liveCooldown").value||"2",10))*1000;
    const now = performance.now();
    if(redPct >= thr){
      LIVE.redStable++;
      if(LIVE.redStable >= stableN && (now - LIVE.lastGrabTs) > cooldownMs){
        LIVE.lastGrabTs = now;
        try{
          const val = await ocrFromROI();
          if(val!=null){
            liveLog(`OCR: ${val.toFixed(2)}√ó (red ${redPct.toFixed(0)}%)`);
            if($("liveAutoAdd").checked){ onNewRound(val); }
          } else { liveLog("OCR: sin n√∫mero claro (ajusta ROI / FPS)"); }
        }catch(e){ liveLog("OCR error: "+(e?.message||e)); }
        LIVE.redStable = 0;
      }
    } else { LIVE.redStable = 0; }
    $("liveInfo").textContent = `Rojo ${redPct.toFixed(1)}% ¬∑ stable ${LIVE.redStable}/${stableN}`;
  } else { $("liveInfo").textContent = `Streaming‚Ä¶ define ROI para activar OCR`; }
  setTimeout(liveLoop, delay);
}
$("roiMode").onclick = ()=>{ LIVE.roiMode = !LIVE.roiMode; $("roiMode").textContent = LIVE.roiMode? "Salir modo ROI" : "Definir ROI"; if(LIVE.roiMode) liveLog("Modo ROI: arrastra en el canvas para seleccionar la zona del n√∫mero."); };
(function attachRoiMouse(){
  const c=$("liveCanvas"); let dragging=false, start=null;
  c.addEventListener("mousedown",(e)=>{ if(!LIVE.roiMode) return; dragging=true; const rect=c.getBoundingClientRect(); start={x:Math.round(e.clientX-rect.left), y:Math.round(e.clientY-rect.top)}; });
  c.addEventListener("mousemove",(e)=>{ if(!LIVE.roiMode || !dragging || !start) return; const rect=c.getBoundingClientRect(); const end={x:Math.round(e.clientX-rect.left), y:Math.round(e.clientY-rect.top)}; const ctx=c.getContext("2d"); ctx.drawImage(LIVE.video,0,0,c.width,c.height); const x=Math.min(start.x,end.x), y=Math.min(start.y,end.y); const w=Math.abs(end.x-start.x), h=Math.abs(end.y-start.y); ctx.save(); ctx.strokeStyle="#60a5fa"; ctx.setLineDash([6,4]); ctx.lineWidth=2; ctx.strokeRect(x,y,w,h); ctx.restore(); });
  c.addEventListener("mouseup",(e)=>{ if(!LIVE.roiMode || !dragging) return; dragging=false; const rect=c.getBoundingClientRect(); const end={x:Math.round(e.clientX-rect.left), y:Math.round(e.clientY-rect.top)}; setROIFromDrag(start,end); LIVE.roiMode=false; $("roiMode").textContent = "Definir ROI"; });
})();
$("liveStart").onclick = async()=>{
  try{
    const fps = Math.max(1, parseInt($("liveFps").value||"3",10));
    LIVE.stream = await navigator.mediaDevices.getDisplayMedia({ video: { frameRate: { ideal: fps, max: fps } }, audio: false });
    LIVE.video = document.createElement("video"); LIVE.video.srcObject = LIVE.stream; await LIVE.video.play();
    LIVE.canvas = $("liveCanvas"); LIVE.ctx = LIVE.canvas.getContext("2d");
    LIVE.running = true; LIVE.redStable = 0; LIVE.lastGrabTs = 0; $("liveInfo").textContent = "Captura iniciada. Define ROI."; liveLog("Captura iniciada.");
    liveLoop();
    LIVE.stream.getVideoTracks()[0].addEventListener("ended", ()=>{ $("liveStop").click(); });
  }catch(e){ liveLog("No se pudo iniciar captura: "+(e?.message||e)); }
};
$("liveStop").onclick = ()=>{ LIVE.running = false; try{ LIVE.stream?.getTracks().forEach(t=>t.stop()); }catch(_){} LIVE.stream=null; LIVE.video=null; $("liveInfo").textContent="Sin captura"; liveLog("Captura detenida."); };

/* Replot */
$("btnReplot").onclick = ()=>{ renderStats(); drawChart(); };

/* Arranque */
function init(){
  ensureModel(); renderStats(); drawChart(); updatePredictionUI(null);
  $("sgPending").textContent="No"; $("sgTotal").textContent="0"; $("sgWins").textContent="0"; $("sgLoss").textContent="0"; $("sgAcc").textContent="0.0%";
}
init();
</script>
</body>
</html>
