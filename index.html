<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Aviator Analyzer ‚Ä¢ Gocho v7.7.0 (Turbo‚Äë60++ & ROSE‚Äëguard)</title>
<style>
  :root{
    --bg:#0f1115; --panel:#171a20; --muted:#98a2b3; --text:#eaeef5;
    --ok:#2ecc71; --warn:#e67e22; --bad:#e74c3c; --brand:#8ab4ff; --pink:#ff5ac3;
    --chip:#232837; --chip-on:#3b4257;
  }
  html,body{background:var(--bg);color:var(--text);font:14px/1.4 system-ui,Inter,Segoe UI,Roboto,Arial,sans-serif;margin:0}
  .wrap{max-width:1080px;margin:20px auto;padding:0 12px}
  .card{background:var(--panel);border-radius:12px;padding:14px;margin:10px 0;border:1px solid #222836}
  h1{font-size:18px;margin:0 0 8px 0;display:flex;gap:8px;align-items:center}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .chip{padding:6px 10px;border-radius:999px;background:var(--chip);cursor:pointer;user-select:none}
  .chip.on{background:var(--chip-on)}
  .btn{background:#2a3042;color:var(--text);border:0;border-radius:8px;padding:8px 12px;cursor:pointer}
  .btn.ok{background:var(--ok);color:#0c0f12;font-weight:700}
  .btn.bad{background:var(--bad)}
  .muted{color:var(--muted)}
  input[type="number"]{width:72px;background:#0f121a;color:var(--text);border:1px solid #2a3144;border-radius:6px;padding:6px}
  input[type="text"]{width:140px;background:#0f121a;color:var(--text);border:1px solid #2a3144;border-radius:6px;padding:6px}
  input[type="range"]{width:180px}
  .pill{display:inline-block;padding:4px 8px;border-radius:999px;background:#1f2432;margin:2px}
  .pill.neu{background:#1c2130}
  .pill.pink{background:rgba(255,90,195,.14);color:#ffb2e3;border:1px solid rgba(255,90,195,.32)}
  .table{width:100%;border-collapse:collapse;font-size:13px}
  .table th,.table td{padding:8px;border-bottom:1px solid #22283a;text-align:left}
  .kpi{display:flex;gap:16px;flex-wrap:wrap}
  .kpi .box{background:#0f121a;border:1px solid #22283a;border-radius:10px;padding:10px 12px}
  .flag{padding:4px 8px;border-radius:6px;background:#22283a}
  .flag.ok{background:rgba(46,204,113,.15);color:#7ff5b0}
  .flag.bad{background:rgba(231,76,60,.12);color:#ff9b9b}
  .flag.warn{background:rgba(230,126,34,.12);color:#ffbf7a}
  .flag.pink{background:rgba(255,90,195,.14);color:#ffb2e3;border:1px solid rgba(255,90,195,.32)}
  .flag.info{background:#1f2432;color:#cbd5e1;border:1px dashed #2a3144}
  .rose-item{display:flex;gap:8px;align-items:center;padding:6px 8px;border:1px solid #22283a;border-radius:8px;margin:5px 0;background:#0f121a}
  .rose-item small{color:var(--muted)}
  .clock{font-variant-numeric:tabular-nums}
</style>
</head>
<body>
<div class="wrap">
  <h1>‚úàÔ∏è Aviator Analyzer ‚Ä¢ <span style="color:#8ab4ff">Gocho v7.7.0</span>
    <span id="statusFeedback" class="muted" style="margin-left:8px"></span>
    <span class="muted" style="margin-left:auto">üïí <b id="clockNow" class="clock">--:--:--</b></span>
  </h1>

  <div class="card">
    <div class="row">
      <div class="row">
        <span class="muted">Objetivo</span>
        <div id="objChips" class="row">
          <div data-v="2"   class="chip">2x</div>
          <div data-v="2.5" class="chip">2.5x</div>
          <div data-v="3"   class="chip on">3x</div>
          <div data-v="3.5" class="chip">3.5x</div>
          <div data-v="4"   class="chip">4x</div>
          <div data-v="5"   class="chip">5x</div>
        </div>
      </div>

      <div class="row" style="margin-left:8px">
        <span class="muted">Modo:</span>
        <div id="modeChips" class="row">
          <div data-m="agresivo"     class="chip">Agresivo</div>
          <div data-m="normal"       class="chip on">Normal</div>
          <div data-m="conservador"  class="chip">Conservador</div>
        </div>
        <label style="margin-left:8px"><input id="autoSignal" type="checkbox" checked> Auto‚Äëse√±al</label>
      </div>

      <div class="row" style="margin-left:auto">
        <span class="muted">Conf. m√≠n.:</span>
        <input id="minConf" type="range" min="50" max="95" value="80"/>
        <span id="minConfVal">80%</span>
        <span class="muted" style="margin-left:8px">CoolDown:</span>
        <input id="cooldown" type="number" min="0" max="50" value="8"/>
      </div>
    </div>

    <div class="row" style="margin-top:10px">
      <button id="startBtn" class="btn ok">Iniciar sesi√≥n</button>
      <button id="stopBtn" class="btn">Cerrar sesi√≥n</button>
      <button id="resetBtn" class="btn">Reset</button>

      <div class="row" style="margin-left:10px">
        <label><input id="beepToggle" type="checkbox" checked> Beep se√±al</label>
      </div>

      <div class="row" style="margin-left:auto">
        <span class="muted">Feed:</span>
        <input id="feedId" type="text" value="gocho"/>
        <button id="connectBtn" class="btn">Conectar feed</button>
        <button id="disconnectBtn" class="btn">Desconectar</button>
      </div>
    </div>
  </div>

  <div class="card">
    <div class="kpi">
      <div class="box">Rondas: <b id="rounds">0</b> <span class="muted">(base)</span></div>
      <div class="box">P(‚â•2x): <b id="p2">0%</b></div>
      <div class="box">P(‚â•2.5x): <b id="p25">0%</b></div>
      <div class="box">P(‚â•3x): <b id="p3">0%</b></div>
      <div class="box">P(‚â•5x): <b id="p5">0%</b></div>
      <div class="box">P(‚â•10x): <b id="p10">0%</b></div>
      <div class="box">MA10: <b id="ma10">‚Äì</b></div>
      <div class="box">Racha &lt;1.70: <b id="badRun">0</b></div>
      <div class="box">CoolDown: <b id="cdLeft">0</b></div>
      <div class="box">Se√±ales: <b id="signals">0</b></div>
      <div class="box">Rosas (‚â•10x): <b id="roseCountLbl">0</b></div>
      <div class="box">Desde √∫ltima Rosa: <b id="sinceRose">‚Äì</b> <span class="muted">r</span><br><span class="muted">√ölt.: <span id="lastRoseLbl">‚Äì</span></span></div>
    </div>

    <div class="row" style="margin-top:10px;gap:8px">
      <span id="zoneFlag" class="flag">Sin se√±al</span>
      <span id="roseAlert" class="flag pink" style="display:none">Alerta Rosa pr√≥xima</span>
      <span id="lastSignal" class="flag ok" style="display:none">Se√±al emitida</span>
      <span id="slotFlag" class="flag info" style="display:none">Ventana 60: 0/60</span>
      <span id="slotExplain" class="flag warn" style="display:none"></span>
    </div>

    <div style="margin-top:12px">
      <div class="muted" style="margin-bottom:6px">√öltimas rondas (m√°s reciente primero)</div>
      <div id="lastRounds"></div>
    </div>
  </div>

  <!-- √Årea de Rosas: intervalos exactos -->
  <div class="card">
    <div class="row">
      <h3 style="margin:0">Rosas (‚â•10x): intervalos exactos entre rosas</h3>
      <span class="muted" style="margin-left:auto">√öltimos 30 enlaces</span>
    </div>
    <div id="roseHistory" style="margin-top:8px"></div>
  </div>

  <div class="card">
    <div class="row"><h3 style="margin:0">Apuestas registradas</h3></div>
    <table class="table" style="margin-top:8px">
      <thead><tr><th>#</th><th>Tipo</th><th>Objetivo</th><th>Stake</th><th>Crash</th><th>Resultado</th><th>P/L</th></tr></thead>
      <tbody id="betsTbody"></tbody>
    </table>
    <div class="row" style="margin-top:10px;gap:6px">
      <button id="hardResetBtn" class="btn bad" title="Borra solo el modelo local (no la historia del feed)">Hard reset modelo (local)</button>
      <label><input id="autoBackup" type="checkbox"/> Auto‚Äëbackup modelo</label>
      <button id="saveModelBtn" class="btn">Guardar modelo</button>
      <button id="loadModelBtn" class="btn">Restaurar modelo</button>
    </div>
  </div>

  <div class="card muted" style="font-size:12px">
    Uso educativo/an√°lisis. No garantiza resultados. ‚ÄúGanada‚Äù = crash &gt; objetivo (igual o menor = p√©rdida).
  </div>
</div>

<!-- Firebase -->
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>

<script>
/*** ===== CONFIG FIREBASE ===== ***/
const firebaseConfig = {
  apiKey: "AIzaSyDuEnNg5XutDF3Ka90o6GFKTazBLR9NnSs",
  authDomain: "aviator-analyzer-b29a7.firebaseapp.com",
  projectId: "aviator-analyzer-b29a7",
  storageBucket: "aviator-analyzer-b29a7.appspot.com",
  messagingSenderId: "575063626276",
  appId: "1:575063626276:web:5f640e41f0ad791d6a3eb1",
  measurementId: "G-325QCBSQMH",
  databaseURL: "https://aviator-analyzer-b29a7-default-rtdb.firebaseio.com"
};
firebase.initializeApp(firebaseConfig);
const db  = firebase.database();
const auth= firebase.auth();

/*** ===== HELPERS UI ===== ***/
const $ = (id)=>document.getElementById(id);
const on=(id,ev,fn)=>{ const el=$(id); if(el) el.addEventListener(ev,fn); };

/*** ===== ESTADO ===== ***/
let FEED_ID = "gocho";
let connected = false;
let loadingBase = false;

let rounds = [];              // n√∫meros (reciente al final)
let roundsMeta = [];          // {v, ts}
let lastShown = [];
let baseCount = 0;

let pendings = [];            // [{id, target, stake, ts, tag, reason, conf}]
let bets = [];
let signalsCount = 0;
let cooldownLeft = 0;

// Rosas
let roses=[];                 // [{idx,v,ts}]
let roseIntervals=[];         // [{from,to,gap}]
let sinceRose = null;         // rondas desde la √∫ltima Rosa
let lastRose = null;          // {v, ts}
let roseAlertActive = false;  // evitar beep continuo

// Guardas ROSE
let roseCD = 0;               // enfriamiento por rondas
let roseLossStreak = 0;       // consecutivas perdidas
let roseAttemptsStartIdx = null;
let roseAttemptsCount = 0;    // m√°x 2 por 120

// Motor 60/120 con extensi√≥n y re‚Äëanclaje
const pred = {
  active:false,
  sessionStartIdx:null,
  winSize:60,
  extendSize:30,
  winStartIdx:null,
  winIndex:1,                 // 1=>P60, 2=>P120, ‚Ä¶
  winSignaled:false,
  extending:false,
  extendStartIdx:null,
  reanchored:false
};

const model = {
  priors: { "2":[10,10], "2.5":[8,10], "3":[6,10], "5":[3,9], "10":[1.5,8.5] },
  winN: 120
};

const ui = {
  selTarget: 3.0,
  mode: "normal",
  autoSignal: true,
  minConf: 80,
  cooldown: 8,
  beep: true
};

/*** ===== UTIL ===== */
const fmtPct=x=>(x*100).toFixed(1)+"%";
const clamp=(v,min,max)=>v<min?min:(v>max?max:v);
const now=()=>Date.now();
const HHmm=ts=>new Date(ts).toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'});

/*** ===== AUDIO ===== */
let audioCtx=null;
function beep(freq=880, ms=120, gain=0.03){
  if(!ui.beep) return;
  try{
    if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)();
    const o = audioCtx.createOscillator(), g = audioCtx.createGain();
    o.type="sine"; o.frequency.value=freq; g.gain.value=gain; o.connect(g); g.connect(audioCtx.destination);
    o.start(); setTimeout(()=>{o.stop();}, ms);
  }catch(_){}
}
const beepPink=()=>{beep(520,160,0.035); setTimeout(()=>beep(980,80,0.03),100);};

/*** ===== M√âTRICAS ===== */
function probGE(k){
  const v=rounds.slice(-model.winN), s=v.filter(x=>x>=k).length, n=v.length;
  const [a,b]=model.priors[String(k)]||[2,2]; return (s+a)/(n+a+b);
}
function probGE_window(k, n){
  const w = rounds.slice(-n);
  const s = w.filter(x=>x>=k).length, L = w.length;
  const [a,b] = model.priors[String(k)] || [2,2];
  return (s+a)/(L+a+b);
}
function movingAverage(arr,n){const L=Math.min(arr.length,n); if(!L) return NaN; let s=0; for(let i=arr.length-L;i<arr.length;i++) s+=arr[i]; return s/L;}
function slopeMA_n(n){ if(rounds.length<n+1) return 0; const nowMA=movingAverage(rounds,n), prevMA=movingAverage(rounds.slice(0,-1),n); return nowMA-prevMA; }
function countBad170(arr, w=8){ return arr.slice(-w).filter(x=>x<1.70).length; }
function inBonusZone(){
  const w=rounds.slice(-14); if(w.length<14) return false;
  const p2=w.filter(x=>x>=2).length/w.length;
  const has5=w.some(x=>x>=5);
  const sl=slopeMA_n(10);
  return (p2>=0.60 && has5 && sl>=0);
}
function drynessSince5x(){ let d=0; for(let i=rounds.length-1;i>=0;i--){ if(rounds[i]>=5) break; else d++; } return d; }
function blueDensity(n=15){const w=rounds.slice(-n); if(!w.length) return 1; const b=w.filter(x=>x<2).length; return b/w.length;}
function hasPurple(n=12){const w=rounds.slice(-n); return w.some(x=>x>=5 && x<10);}
function maxBlueRun(n=12){const w=rounds.slice(-n); let maxR=0,cur=0; for(const x of w){ if(x<2){cur++; maxR=Math.max(maxR,cur);} else cur=0; } return maxR; }

/*** ===== ROSAS: hazard + contexto ===== */
function roseHazardNext(){
  if(roseIntervals.length<5 || sinceRose==null) return {h:0, eta:null, q75:0, q80:0};
  const gaps = roseIntervals.map(x=>x.gap);
  const maxG = Math.max(...gaps);
  const freq = new Map();
  for(const g of gaps) freq.set(g, (freq.get(g)||0)+1);
  const N = gaps.length;
  const pdf = []; const cdf = [];
  let cum=0;
  for(let t=1;t<=maxG+20;t++){
    const p = (freq.get(t)||0)/N;
    pdf[t]=p; cum+=p; cdf[t]=cum;
  }
  const hazards = [];
  for(let t=1;t<=maxG+20;t++){
    const S = 1-(cdf[t-1]||0);
    hazards[t] = S>0 ? pdf[t]/S : 0;
  }
  const hazVals = hazards.filter(x=>x>0).sort((a,b)=>a-b);
  const q75 = hazVals.length? hazVals[Math.floor(0.75*(hazVals.length-1))] : 0.12;
  const q80 = hazVals.length? hazVals[Math.floor(0.80*(hazVals.length-1))] : 0.15;
  const tNext = sinceRose+1;
  let eta=null, bestH=0;
  for(let t=tNext; t<tNext+20; t++){
    if(hazards[t]>q75 && hazards[t]>bestH){ bestH=hazards[t]; eta=t-sinceRose; }
  }
  return {h:hazards[tNext]||0, eta, q75, q80};
}

/*** ===== SE√ëALES ===== */
function emitSignal(target, tag="AUTO", beepKind="green", reason="", conf=0){
  const id="S"+now();
  pendings.push({id, target, stake:1, ts:now(), state:"pend", tag, reason, conf});
  signalsCount++; cooldownLeft=ui.cooldown;
  renderBets();
  const sig=$("lastSignal");
  sig.style.display="inline-block"; sig.textContent = `Se√±al ${tag}: ${target}x`;
  setTimeout(()=>sig.style.display="none", 3500);
  if(beepKind==="pink") beepPink(); else beep(880,140,0.04);
}

/*** ===== Turbo‚Äë60 (score) ===== */
function scoreEntry(){
  const target = ui.selTarget;                         // 3 o 5
  const p60 = probGE_window(target, 60);
  const p20 = probGE_window(target, 20);
  const sl10 = slopeMA_n(10);
  const sl5  = slopeMA_n(5);
  const blue15 = blueDensity(15);                      // 0..1 (m√°s bajo, mejor)
  const dry = clamp(drynessSince5x()/60, 0, 1);
  const bonus = inBonusZone()?1:0;
  const purple = hasPurple(12)?1:0;

  // normalizaciones/ponderaciones
  const f_sl10 = clamp((sl10+0.08)/0.12, 0, 1);
  const f_sl5  = clamp((sl5 +0.06)/0.10, 0, 1);
  const f_blue = 1 - clamp(blue15, 0, 1);

  const score = 0.30*p60 + 0.22*p20 + 0.15*f_sl10 + 0.10*f_sl5 + 0.10*f_blue + 0.07*bonus + 0.06*dry + 0.05*purple;

  return {score, target, p60, p20, sl10, sl5, blue15, dry, bonus, purple};
}
function explainWhy(pLike, sl10, blue15, bad, haz){
  const parts=[];
  if(pLike<0.33) parts.push(`probabilidad baja (${fmtPct(pLike)})`);
  if(sl10<0) parts.push(`tendencia bajista (${sl10.toFixed(3)})`);
  if(blue15>0.55) parts.push(`muchas azules (densidad ${(100*blue15).toFixed(0)}%)`);
  if(bad>=5) parts.push(`zona mala <1.70 (${bad}/8)`);
  if(haz && haz.h < (haz.q75||0)) parts.push(`prob. de Rosa no destacada`);
  if(!parts.length) parts.push(`criterios estrictos a√∫n no se cumplen`);
  return "Sin entrada s√≥lida: " + parts.join(" ¬∑ ");
}

/*** ===== Motor 60/120 con extensi√≥n y re‚Äëanclaje ===== */
function startPredSession(){
  pred.active=true;
  pred.sessionStartIdx=rounds.length;
  pred.winStartIdx=rounds.length;
  pred.winIndex=1;
  pred.winSignaled=false;
  pred.extending=false;
  pred.extendStartIdx=null;
  pred.reanchored=false;
  $("slotFlag").style.display="inline-block";
  $("slotExplain").style.display="none";
  updateSlotFlag();
}
function stopPredSession(){
  pred.active=false;
  $("slotFlag").style.display="none";
  $("slotExplain").style.display="none";
}
function updateSlotFlag(){
  if(!pred.active) return;
  const done = rounds.length - pred.winStartIdx;
  let txt = `Ventana ${pred.winIndex*60}: ${Math.max(0,done)}/${pred.winSize}`;
  if(pred.extending){
    const ext = rounds.length - pred.extendStartIdx;
    txt += ` ‚Ä¢ extensi√≥n ${ext}/${pred.extendSize}`;
  }
  if(pred.reanchored) txt += " ‚Ä¢ re‚Äëanclada";
  $("slotFlag").textContent = txt;
}
function maybeReanchorWindow(){
  if(!pred.active || pred.reanchored || pred.winSignaled) return;
  const done = rounds.length - pred.winStartIdx;
  if(done<8 && countBad170(rounds,8)>=6){
    pred.winStartIdx = rounds.length;
    pred.reanchored = true;
    $("slotExplain").style.display="inline-block";
    $("slotExplain").textContent = "Re‚Äëanclaje: racha <1.70 muy alta al inicio; esperando estructura limpia";
    updateSlotFlag();
  }
}
function tickPredEngine(){
  if(!pred.active) return;

  const done = rounds.length - pred.winStartIdx;
  const within60 = done < pred.winSize;

  const {score, target, p60, p20, sl10, sl5, blue15, dry, bonus, purple} = scoreEntry();
  const bad = countBad170(rounds,8);
  const haz = roseHazardNext();

  // umbral adaptativo por fase
  const phase = clamp(done / pred.winSize, 0, 1);
  const baseThr = (target==5) ? 0.92 : 0.86;
  const endThr  = (target==5) ? 0.66 : 0.58;
  const thr = baseThr - (baseThr-endThr)*phase;

  // requisitos m√≠nimos
  const minP20 = (target==5) ? 0.14 : 0.30;
  const minSl  = (target==5) ? -0.001 : -0.004;
  const maxBlueD = 0.55;

  const pLike = (target==5)? probGE_window(5, 60) : probGE_window(3, 60);

  const gate = (score>=thr) && (p20>=minP20) && (sl10>=minSl) && (blue15<=maxBlueD) && (bad<6);

  if(!pred.winSignaled && gate && ui.autoSignal && cooldownLeft<=0){
    const tag = (pred.winIndex%2===1) ? "P60" : "P120";
    const conf = clamp(score, 0, 1);
    const reason = `score=${(100*score).toFixed(0)} ‚Ä¢ p20=${fmtPct(p20)} ‚Ä¢ p60=${fmtPct(p60)} ‚Ä¢ sl10=${sl10.toFixed(3)} ‚Ä¢ blue15=${(100*blue15).toFixed(0)}% ‚Ä¢ bonus=${bonus} ‚Ä¢ purple=${purple}`;
    emitSignal(target, tag, "green", reason, conf);
    pred.winSignaled = true;

    // abrir nueva ventana a partir de la SIGUIENTE ronda
    pred.winIndex++;
    pred.winStartIdx = rounds.length;
    pred.extending=false; pred.extendStartIdx=null; pred.reanchored=false;
    $("slotExplain").style.display="none";
    updateSlotFlag();
    return;
  }

  // Fin de 60 sin se√±al => extensi√≥n 30 con explicaci√≥n
  if(!pred.winSignaled && !pred.extending && !within60){
    pred.extending = true;
    pred.extendStartIdx = rounds.length;
    const el = $("slotExplain"); el.style.display="inline-block";
    el.textContent = explainWhy(pLike, sl10, blue15, bad, haz);
  }

  if(pred.extending){
    $("slotExplain").style.display="inline-block";
    $("slotExplain").textContent = explainWhy(pLike, sl10, blue15, bad, haz);

    // si aparece el set‚Äëup real durante la extensi√≥n, disparo
    const gateExt = gate; // mismo gate
    if(!pred.winSignaled && gateExt && ui.autoSignal && cooldownLeft<=0){
      const tag = (pred.winIndex%2===1) ? "P60" : "P120";
      const conf = clamp(score, 0, 1);
      const reason = `EXT ‚Ä¢ score=${(100*score).toFixed(0)} ‚Ä¢ p20=${fmtPct(p20)} ‚Ä¢ sl10=${sl10.toFixed(3)} ‚Ä¢ blue15=${(100*blue15).toFixed(0)}%`;
      emitSignal(target, tag, "green", reason, conf);
      pred.winSignaled = true;

      pred.winIndex++;
      pred.winStartIdx = rounds.length;
      pred.extending=false; pred.extendStartIdx=null; pred.reanchored=false;
      $("slotExplain").style.display="none";
    }
  }

  updateSlotFlag();
}

/*** ===== RENDER ===== */
function renderStats(){
  const p2=probGE(2),p25=probGE(2.5),p3=probGE(3),p5=probGE(5),p10=probGE(10), ma10=movingAverage(rounds,10), bad=countBad170(rounds,8);
  $("rounds").textContent=`${rounds.length} (base ${baseCount})`;
  $("p2").textContent=fmtPct(p2); $("p25").textContent=fmtPct(p25); $("p3").textContent=fmtPct(p3);
  $("p5").textContent=fmtPct(p5); $("p10").textContent=fmtPct(p10);
  $("ma10").textContent=isNaN(ma10)?"‚Äì":(ma10.toFixed(2)+"x");
  $("badRun").textContent=bad; $("cdLeft").textContent=cooldownLeft; $("signals").textContent=signalsCount;

  const zone=$("zoneFlag");
  if(bad>=7) { zone.className="flag bad"; zone.textContent="Zona mala: bloqueo <1.70"; }
  else if(inBonusZone()) { zone.className="flag ok"; zone.textContent="Bonus zone (tendencia alcista)"; }
  else { zone.className="flag"; zone.textContent="Sin se√±al"; }

  $("roseCountLbl").textContent = roses.length;
  $("sinceRose").textContent = (sinceRose==null?"‚Äì":sinceRose);
  $("lastRoseLbl").textContent = lastRose?(`${lastRose.v.toFixed(2)}x ‚Ä¢ ${HHmm(lastRose.ts)}`):"‚Äì";

  const cont=$("lastRounds"); cont.innerHTML="";
  lastShown.forEach(x=>{ const d=document.createElement("span"); d.className="pill neu"; d.textContent=x.toFixed(2)+"x"; cont.appendChild(d); });
}
function renderBets(){
  const tb=$("betsTbody"); tb.innerHTML="";
  bets.concat(pendings).forEach((b,idx)=>{
    const st = b.state==="win"?"win": b.state==="lose"?"lose":"pend";
    const tr=document.createElement("tr");
    tr.title = (b.reason?`Motivo: ${b.reason} ‚Ä¢ Conf‚âà${Math.round((b.conf||0)*100)}%`:"");
    tr.innerHTML = `<td>${idx+1}</td><td>${b.tag||"AUTO"}</td><td>${b.target}x</td><td>$${b.stake.toFixed?b.stake.toFixed(2):b.stake}</td><td>${b.crash? b.crash.toFixed(2)+"x":"‚Äî"}</td><td>${st}</td><td>${b.pl||"‚Äî"}</td>`;
    tb.appendChild(tr);
  });
}
function renderRoseHistory(){
  const cont = $("roseHistory");
  cont.innerHTML = "";
  const items = roseIntervals.slice(-30).reverse();
  if(!items.length){
    const d=document.createElement("div");
    d.className="muted"; d.textContent="A√∫n no hay enlaces entre rosas (‚â•10x).";
    cont.appendChild(d); return;
  }
  items.forEach((it)=>{
    const row = document.createElement("div");
    row.className = "rose-item";
    row.innerHTML = `
      <span class="pill pink">${it.from.v.toFixed(2)}x</span>
      <small>${HHmm(it.from.ts)}</small>
      <span class="muted">‚Üí</span>
      <span class="pill pink">${it.to.v.toFixed(2)}x</span>
      <small>${HHmm(it.to.ts)}</small>
      <span class="muted">en</span>
      <b>${it.gap}</b> <span class="muted">rondas</span>`;
    cont.appendChild(row);
  });
}

/*** ===== ROSAS: actualizaci√≥n por ronda ===== */
function handleRoseMeta(v, ts){
  if(v>=10){
    const idx = rounds.length-1;
    const item = {idx, v, ts};
    roses.push(item);
    if(roses.length>=2){
      const prev = roses[roses.length-2];
      const gap = item.idx - prev.idx;
      roseIntervals.push({from:prev, to:item, gap});
      if(roseIntervals.length>30) roseIntervals.shift();
    }
    lastRose = {v, ts};
    sinceRose = 0;
    roseAlertActive = false;
    $("roseAlert").style.display="none";
    renderRoseHistory();
  }else{
    if(sinceRose==null) sinceRose = 1;
    else sinceRose++;
  }

  // Guardas ROSE (cooldown y l√≠mite/racha)
  if(roseCD>0) roseCD--;

  const hazard = roseHazardNext();
  const sl10 = slopeMA_n(10);
  const blueD = blueDensity(15);
  const blueRun = maxBlueRun(12);
  const purple = hasPurple(12);
  const okCtx = (sl10>=0) && (blueRun<=3) && (blueD<=0.45) && purple;

  // Pre‚Äëalerta
  if(hazard.h>0 && hazard.h >= hazard.q75){
    $("roseAlert").style.display="inline-block";
    $("roseAlert").textContent = hazard.eta ? `Alerta Rosa (~${hazard.eta} r)` : `Alerta Rosa pr√≥xima`;
    if(!roseAlertActive){ roseAlertActive=true; beepPink(); }
  }else{
    if(roseAlertActive){ roseAlertActive=false; }
    $("roseAlert").style.display="none";
  }

  // Disparo ROSE m√°s estricto
  const canTryWindow = (()=>{ // m√°x 2 por 120
    const curIdx = rounds.length;
    if(roseAttemptsStartIdx==null || (curIdx - roseAttemptsStartIdx)>120){
      roseAttemptsStartIdx = curIdx; roseAttemptsCount = 0;
    }
    return (roseAttemptsCount < 2);
  })();

  if(hazard.h>0 && hazard.h >= Math.max(hazard.q80,0.16) && okCtx && ui.autoSignal && cooldownLeft<=0 && roseCD<=0 && roseLossStreak<2 && canTryWindow){
    const conf = clamp( 0.55*hazard.h + 0.15*(inBonusZone()?1:0) + 0.15*(1-blueD) + 0.15*(purple?1:0) , 0, 1);
    const reason = `haz=${(100*hazard.h).toFixed(0)} (q80‚âà${(100*hazard.q80).toFixed(0)}) ‚Ä¢ MA10=${sl10.toFixed(3)} ‚Ä¢ blue15=${(100*blueD).toFixed(0)}% ‚Ä¢ purple=${purple} ‚Ä¢ runBlue‚â§${blueRun}`;
    emitSignal(10, "ROSE", "pink", reason, conf);
    roseCD = 12;
    roseAttemptsCount++;
  }
}

/*** ===== onNewCrash ===== */
function onNewCrash(v, ts, isBase=false){
  rounds.push(v);
  roundsMeta.push({v,ts});
  if(rounds.length>2000){ rounds.shift(); roundsMeta.shift(); }
  if(!isBase && cooldownLeft>0) cooldownLeft--;

  handleRoseMeta(v, ts);

  // asignar apuestas pendientes SOLO en vivo
  if(!isBase && pendings.length){
    const bet = pendings.shift();
    const win = (v > bet.target);
    bet.crash = v; bet.state = win?"win":"lose"; bet.pl = win? "+1" : "‚àí1";

    // actualizar guardas ROSE
    if(bet.tag==="ROSE"){
      if(win) roseLossStreak=0;
      else roseLossStreak++;
    }

    bets.push(bet);
    renderBets();
  }

  lastShown.unshift(v); if(lastShown.length>60) lastShown.pop();

  renderStats();

  if(!isBase){
    maybeReanchorWindow();
    tickPredEngine();
  }

  lastActivityTs = ts || Date.now();
}

/*** ===== CONEXI√ìN FEED + auto‚Äëreconnect ===== */
function processValue(raw){ if(raw===null||raw===undefined) return null; const s=String(raw).replace(/,/g,''); const c=s.replace(/[^\d.]/g,''); if(c==='') return null; const v=Number(c); return (v>=1&&!isNaN(v))?v:null; }
let liveRef=null, liveCb=null, lastSeenKey=null, lastSeenTs=null;
let lastActivityTs=null, watchdog=null;

async function connectFeed(){
  if(connected) return;
  FEED_ID=($("feedId").value||"gocho").trim();
  const feedbackEl=$("statusFeedback");
  const refPath=`feeds/${FEED_ID}/crashes`;
  feedbackEl&&(feedbackEl.textContent=`Conectando a ${refPath}‚Ä¶`);

  try{ await auth.signInAnonymously(); }catch(e){ console.warn("[auth] an√≥nimo no habilitado:", e?.message||e); }

  const ref=db.ref(refPath);
  loadingBase=true; feedbackEl&&(feedbackEl.textContent="Cargando historial‚Ä¶");

  let snap=null, method="key";
  try{
    const s1=await ref.orderByChild("ts").limitToLast(800).once("value");
    if(s1 && s1.val() && Object.keys(s1.val()).length){ snap=s1; method="ts"; }
  }catch(e){ console.warn("[rtdb] orderByChild(ts) fall√≥:", e?.message||e); }
  if(!snap){
    try{ snap=await ref.orderByKey().limitToLast(800).once("value"); method="key"; }
    catch(e){ console.error("[rtdb] orderByKey fall√≥:", e?.message||e); }
  }
  if(!snap || !snap.val()){ feedbackEl&&(feedbackEl.textContent="Sin datos en el feed."); loadingBase=false; return; }

  const data=snap.val(), keys=Object.keys(data).sort();
  baseCount=keys.length;

  // reset buffers
  rounds=[]; roundsMeta=[]; lastShown=[]; roses=[]; roseIntervals=[]; sinceRose=null; lastRose=null; roseAlertActive=false;
  bets=[]; pendings=[]; signalsCount=0; cooldownLeft=0;
  roseCD=0; roseLossStreak=0; roseAttemptsStartIdx=null; roseAttemptsCount=0;

  keys.forEach(k=>{
    const node=data[k]; const v=processValue(node?.v ?? node); const ts=Number(node?.ts ?? k) || now();
    if(v!==null) onNewCrash(v, ts, /*isBase*/true);
  });

  lastSeenKey=keys[keys.length-1]||null;
  lastSeenTs = (()=>{ const n=data[lastSeenKey]; const t=Number(n?.ts ?? lastSeenKey); return isFinite(t)?t:now(); })();
  lastActivityTs = lastSeenTs;

  loadingBase=false;

  // vivo
  if(method==="ts"){
    liveRef=ref.orderByChild("ts").startAt(lastSeenTs);
    liveCb=function(s){
      const key=s.key, d=s.val(); const v=processValue(d?.v ?? d); const ts=Number(d?.ts ?? key) || now();
      if(lastSeenTs && ts<=lastSeenTs && key===lastSeenKey) return;
      lastSeenKey=key; lastSeenTs=ts;
      if(v!==null) onNewCrash(v, ts, /*isBase*/false);
    };
  }else{
    liveRef=ref.orderByKey().startAt(lastSeenKey||"");
    liveCb=function(s){
      const key=s.key, d=s.val(); if(lastSeenKey && key<=lastSeenKey) return; lastSeenKey=key;
      const v=processValue(d?.v ?? d); const ts=Number(d?.ts ?? key) || now();
      if(v!==null) onNewCrash(v, ts, /*isBase*/false);
    };
  }
  liveRef.on("child_added", liveCb);

  // watchdog auto‚Äëreconnect
  if(watchdog) clearInterval(watchdog);
  watchdog = setInterval(()=>{
    if(!connected) return;
    const delta = Date.now() - (lastActivityTs||0);
    if(delta > 180000){ // >3 min sin actividad
      console.warn("[watchdog] Reintentando conexi√≥n‚Ä¶");
      disconnectFeed(true); connectFeed();
    }
  }, 30000);

  connected=true; feedbackEl&&(feedbackEl.textContent="Conectado.");
  renderStats(); renderRoseHistory();
}

function disconnectFeed(silent=false){
  if(!connected) return;
  if(liveRef && liveCb) liveRef.off("child_added", liveCb);
  liveRef=null; liveCb=null; lastSeenKey=null; lastSeenTs=null; connected=false;
  if(watchdog){ clearInterval(watchdog); watchdog=null; }
  const feedbackEl=$("statusFeedback"); if(!silent) feedbackEl&&(feedbackEl.textContent="Desconectado.");
}

/*** ===== BACKUP / RESTORE ===== */
function saveModel(){
  const obj={model, ui:{minConf:ui.minConf, cooldown:ui.cooldown, mode:ui.mode, autoSignal:ui.autoSignal}};
  auth.currentUser?Promise.resolve():auth.signInAnonymously(); return db.ref(`feeds/${FEED_ID}/state/model_v1`).set(obj);
}
function loadModel(){
  return db.ref(`feeds/${FEED_ID}/state/model_v1`).once("value").then(s=>{
    const v=s.val(); if(!v) return;
    if(v.model) Object.assign(model,v.model);
    if(v.ui){
      ui.minConf=v.ui.minConf??ui.minConf; ui.cooldown=v.ui.cooldown??ui.cooldown; ui.mode=v.ui.mode??ui.mode;
      if(typeof v.ui.autoSignal==="boolean") ui.autoSignal=v.ui.autoSignal;
      applyUIFromState();
    }
  });
}

/*** ===== UI BINDINGS ===== */
function applyUIFromState(){
  document.querySelectorAll("#objChips .chip").forEach(el=>el.classList.toggle("on", Number(el.dataset.v)==ui.selTarget));
  document.querySelectorAll("#modeChips .chip").forEach(el=>el.classList.toggle("on", el.dataset.m===ui.mode));
  $("minConf").value=ui.minConf; $("minConfVal").textContent=ui.minConf+"%";
  $("cooldown").value=ui.cooldown; $("beepToggle").checked=ui.beep;
  $("autoSignal").checked=ui.autoSignal;
}
on("objChips","click",e=>{ const el=e.target.closest(".chip"); if(!el) return; document.querySelectorAll("#objChips .chip").forEach(x=>x.classList.remove("on")); el.classList.add("on"); ui.selTarget=Number(el.dataset.v); });
on("modeChips","click",e=>{ const el=e.target.closest(".chip"); if(!el) return; document.querySelectorAll("#modeChips .chip").forEach(x=>x.classList.remove("on")); el.classList.add("on"); ui.mode=el.dataset.m; });
on("autoSignal","change",e=> ui.autoSignal=e.target.checked);
on("minConf","input",e=>{ ui.minConf=Number(e.target.value); $("minConfVal").textContent=ui.minConf+"%"; });
on("cooldown","change",e=> ui.cooldown=Number(e.target.value));
on("beepToggle","change",e=> ui.beep=e.target.checked);

on("connectBtn","click", connectFeed);
on("disconnectBtn","click", ()=>disconnectFeed(false));

on("startBtn","click", ()=>{
  signalsCount=0; cooldownLeft=0; bets=[]; pendings=[]; renderBets(); renderStats(); beep(660,90,0.03);
  startPredSession();
});
on("stopBtn","click", ()=>{
  bets=[]; pendings=[]; signalsCount=0; cooldownLeft=0; renderBets(); renderStats();
  stopPredSession();
});
on("resetBtn","click", ()=>{
  bets=[]; pendings=[]; signalsCount=0; cooldownLeft=0; renderBets(); renderStats();
  stopPredSession();
});

on("hardResetBtn","click", ()=>{ localStorage.clear(); location.reload(); });
on("saveModelBtn","click", ()=>{ saveModel(); });
on("loadModelBtn","click", ()=>{ loadModel().then(()=>renderStats()); });
on("autoBackup","change", e=>{ if(e.target.checked){ saveModel(); }});

/*** ===== Reloj ===== */
setInterval(()=>{ $("clockNow").textContent=new Date().toLocaleTimeString(); }, 1000);

/*** ===== Arranque ===== */
(function bootstrap(){
  try{ const st=JSON.parse(localStorage.getItem("gocho_ui_state")||"{}"); Object.assign(ui,st); }catch(_){}
  applyUIFromState();
  setInterval(()=>localStorage.setItem("gocho_ui_state", JSON.stringify(ui)), 2000);
})();
</script>
</body>
</html>
