<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Aviator Learner ‚Äì Bot completo (SGD + Live OCR)</title>
<style>
  :root { --bg:#0f172a; --card:#0b1220; --muted:#94a3b8; --text:#e5e7eb; --accent:#60a5fa; --ok:#22c55e; --bad:#ef4444; }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,Segoe UI,Inter,Roboto,Arial}
  .wrap{max-width:1120px;margin:0 auto;padding:20px}
  h1{margin:0 0 8px;font-size:22px}
  h2{margin:0 0 8px;font-size:18px}
  .card{background:var(--card);border:1px solid #1f2937;border-radius:14px;padding:14px;margin-top:12px}
  .row{display:grid;grid-template-columns:1fr;gap:12px}
  @media(min-width:1024px){ .row2{grid-template-columns:2fr 1fr} }
  textarea,input,select,button{border-radius:10px;border:1px solid #334155;background:#0b1220;color:var(--text)}
  textarea{width:100%;min-height:90px;padding:8px}
  input,select{padding:8px;width:100%}
  .btn{padding:8px 12px;background:#111827;border:1px solid #334155;cursor:pointer;border-radius:10px}
  .btn:hover{border-color:#475569}
  .muted{color:var(--muted);font-size:13px}
  .rowflex{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .pill{padding:2px 8px;border:1px solid #334155;border-radius:999px;font-size:12px}
  .signal{font-weight:700} .ok{color:var(--ok)} .no{color:var(--bad)}
  .small{font-size:12px}
  .table{width:100%;border-collapse:collapse;font-size:13px}
  .table td,.table th{border-bottom:1px solid #1f2937;padding:6px 4px;text-align:left}
  canvas.chart{width:100%;height:280px;background:#0a0f1f;border:1px solid #1f2937;border-radius:12px}
  canvas.live{width:100%;height:260px;background:#0a0f1f;border:1px solid #1f2937;border-radius:12px}
</style>
</head>
<body>
<div class="wrap">
  <h1>üß™ Aviator Learner <span class="pill">online ¬∑ educativo ¬∑ sin autobet</span></h1>

  <div class="row row2">
    <div>
      <!-- Entrada -->
      <div class="card">
        <h2>Entrada de rondas</h2>
        <textarea id="ta" placeholder="Pega multiplicadores: 1.2 2.4 8.3 145 1.1 ..."></textarea>
        <div class="rowflex">
          <button class="btn" id="btnAdd">A√±adir</button>
          <button class="btn" id="btnClear">Limpiar</button>
          <input id="quick" placeholder="R√°pido: 123 => 1.23" style="width:160px">
          <button class="btn" id="btnQuick">A√±adir r√°pido</button>
        </div>
      </div>

      <!-- Modelo y filtros -->
      <div class="card">
        <h2>Modelo online (SGD) + filtros de se√±al</h2>
        <div class="rowflex">
          <label>Target ‚â• <input id="inpTarget" type="number" step="0.1" value="3" style="width:80px"></label>
          <label>Umbral p‚â• <input id="inpThresh" type="number" step="0.01" value="0.80" style="width:80px"></label>
          <label>Hist. m√≠nimo N<input id="inpMinN" type="number" value="10" style="width:80px"></label>
          <label>Ventana W<input id="inpW" type="number" value="40" style="width:80px"></label>
          <label>LR Œ±<input id="inpLR" type="number" step="0.001" value="0.02" style="width:80px"></label>
          <label>L2 Œª<input id="inpL2" type="number" step="0.0001" value="0.001" style="width:90px"></label>
        </div>
        <div class="rowflex" style="margin-top:6px">
          <label>Cooldown (rondas) <input id="gateCooldown" type="number" value="8" style="width:80px"></label>
          <label>W_low <input id="gateWlow" type="number" value="20" style="width:80px"></label>
          <label>Œº_min <input id="gateMuMin" type="number" step="0.01" value="1.30" style="width:80px"></label>
          <label>K d√©biles <input id="gateK" type="number" value="8" style="width:80px"></label>
          <label>Debil < L <input id="gateL" type="number" step="0.01" value="1.30" style="width:80px"></label>
          <label>M√°x d√©biles M <input id="gateM" type="number" value="3" style="width:80px"></label>
        </div>
        <div class="rowflex" style="margin-top:6px">
          <label>Bloquear si Bajista <input id="gateBlockBear" type="checkbox" checked></label>
          <label>T (temperatura) <input id="gateT" type="number" step="0.1" value="1.9" style="width:80px"></label>
          <label>Umbral adaptativo <input id="gateAdaptive" type="checkbox"></label>
          <label>Precisi√≥n objetivo <input id="gateTargetAcc" type="number" step="0.01" value="0.65" style="width:80px"></label>
        </div>
        <div class="rowflex" style="margin-top:6px">
          <button class="btn" id="btnReset">Reiniciar modelo</button>
          <button class="btn" id="btnExportModel">Exportar modelo</button>
          <label class="btn"><input type="file" id="fileModel" accept=".json" hidden>Importar modelo</label>
        </div>
        <div style="margin-top:8px">
          <div>Prob. estimada pr√≥xima ‚â• target: <span id="prob" class="signal">‚Äî</span></div>
          <div>Se√±al: <span id="signal" class="signal no">‚Äî</span></div>
          <div class="muted small">‚ÄúSe√±al‚Äù ‚â† garant√≠a. √ösalo solo como an√°lisis formativo (demo).</div>
        </div>
      </div>

      <!-- Gr√°fica -->
      <div class="card">
        <div class="rowflex" style="justify-content:space-between;gap:12px">
          <h2>Gr√°fica (cap 200√ó) + Tendencia</h2>
          <div class="rowflex">
            <label>Ventana (W) <input id="trW" type="number" value="40" style="width:90px"></label>
            <label>Umbral pendiente <input id="trEps" type="number" step="0.001" value="0.01" style="width:90px"></label>
            <button class="btn" id="btnReplot">Recalcular</button>
          </div>
        </div>
        <canvas id="chart" class="chart" width="1080" height="280"></canvas>
      </div>
    </div>

    <!-- Columna derecha -->
    <div>
      <div class="card">
        <h2>Estad√≠sticas</h2>
        <table class="table small">
          <tr><th>N (rondas)</th><td id="stN">0</td></tr>
          <tr><th>Media</th><td id="stMean">0.00√ó</td></tr>
          <tr><th>Mediana</th><td id="stMed">0.00√ó</td></tr>
          <tr><th>P(‚â•3√ó)</th><td id="stP3">0.0%</td></tr>
          <tr><th>P(‚â•5√ó)</th><td id="stP5">0.0%</td></tr>
          <tr><th>M√°x</th><td id="stMax">0.00√ó</td></tr>
          <tr><th>Tendencia</th><td id="stTrend">‚Äî</td></tr>
        </table>
      </div>

      <div class="card">
        <h2>Se√±ales</h2>
        <table class="table small">
          <tr><th>Pendiente abierta</th><td id="sgPending">No</td></tr>
          <tr><th>Total se√±ales</th><td id="sgTotal">0</td></tr>
          <tr><th>Ganadas</th><td id="sgWins">0</td></tr>
          <tr><th>Perdidas</th><td id="sgLoss">0</td></tr>
          <tr><th>Precisi√≥n</th><td id="sgAcc">0.0%</td></tr>
        </table>
      </div>

      <!-- Live OCR -->
      <div class="card">
        <h2>Captura en tiempo real (ROI autom√°tico + offsets)</h2>
        <div class="rowflex">
          <button class="btn" id="liveStart">Iniciar captura</button>
          <button class="btn" id="liveStop">Detener</button>
          <label><input type="checkbox" id="liveAutoAdd" checked> Auto-agregar tras OCR</label>
        </div>
        <div class="rowflex" style="margin-top:6px">
          <label>FPS <input id="liveFps" type="number" value="3" style="width:80px"></label>
          <label>Umbral rojo (%) <input id="redPct" type="number" step="1" value="25" style="width:80px"></label>
          <label>Estabilidad (frames) <input id="stableN" type="number" value="2" style="width:80px"></label>
          <label>Cooldown (s) <input id="liveCooldown" type="number" value="2" style="width:80px"></label>
        </div>
        <div class="rowflex" style="margin-top:6px">
          <label>Offset X <input id="roiOffsetX" type="number" value="0" style="width:80px"></label>
          <label>Offset Y <input id="roiOffsetY" type="number" value="0" style="width:80px"></label>
        </div>
        <div class="muted small">Comparte la pesta√±a del juego. El recorte se centra solo; ajusta <b>Offset X/Y</b> si el n√∫mero queda corrido.</div>
        <canvas id="liveCanvas" class="live" width="560" height="315"></canvas>
        <div class="muted small" id="liveInfo">Sin captura</div>
        <div class="muted small" id="liveLog" style="max-height:180px;overflow:auto;border:1px solid #1f2937;border-radius:8px;padding:6px;margin-top:6px"></div>
      </div>
    </div>
  </div>

  <div class="card"><p class="muted small">Descargo: herramienta educativa. No garantiza resultados ni interact√∫a con el sitio.</p></div>
</div>

<script>
/* ===== Utilidades ===== */
const $ = (id)=>document.getElementById(id);
function parseList(s){ if(!s) return []; return s.split(/[\s,;]+/).map(t=>t.trim()).filter(Boolean).map(Number).filter(x=>isFinite(x)&&x>0); }
function median(a){ if(!a.length) return 0; const s=[...a].sort((x,y)=>x-y); const m=Math.floor(s.length/2); return s.length%2?s[m]:(s[m-1]+s[m])/2; }
function stats(arr){
  const n=arr.length; if(!n) return {n:0,mean:0,med:0,max:0,p3:0,p5:0};
  const sum=arr.reduce((a,b)=>a+b,0), mean=sum/n, med=median(arr), max=Math.max(...arr);
  const p=(t)=>arr.filter(x=>x>=t).length/n;
  return {n,mean,med,max,p3:p(3),p5:p(5)};
}
function last(arr,k){ return arr.slice(Math.max(0,arr.length-k)); }
function clampSeries(data,cap=200){ return data.map((v,i)=>({i:i+1,m:Math.min(v,cap),real:v})); }
function quickNorm(s){ s=(s||"").trim(); if(!s) return null; if(!s.includes(".") && /^\d{2,4}$/.test(s)){ if(s.length===2) s=s[0]+"."+s[1]; else if(s.length===3) s=s[0]+"."+s.slice(1); else s=s.slice(0,2)+"."+s.slice(2);} const v=parseFloat(s.replace(',','.')); return (isFinite(v)&&v>0)?v:null; }

/* ===== Rasgos para el modelo ===== */
function featuresFrom(history, W, target){
  const H = last(history, W); const n = H.length; if(n===0) return new Array(15).fill(0);
  const caps = H.map(v=>Math.min(v, 50));
  const logs = caps.map(v=>Math.log(1+v));
  const mean = caps.reduce((a,b)=>a+b,0)/n;
  const meanLog = logs.reduce((a,b)=>a+b,0)/n;
  const med = median(caps);
  const std = Math.sqrt((caps.reduce((a,b)=>a+(b-mean)**2,0)/n)||0);
  const p3 = caps.filter(v=>v>=3).length/n;
  const p5 = caps.filter(v=>v>=5).length/n;
  let up=0, down=0; // rachas
  for(let i=caps.length-1;i>=0;i--){ if(caps[i]>=target){ up++; if(down===0){} else break; } else { down++; if(up===0){} else break; } }
  const L = last(caps,5); while(L.length<5) L.unshift(0);
  let sinceHi=0; for(let i=caps.length-1;i>=0;i--){ if(caps[i]>=target) break; sinceHi++; }
  return [1, mean, med, std, meanLog, p3, p5, up, down, sinceHi, ...L];
}

/* ===== Regresi√≥n log√≠stica online (SGD + L2) ===== */
class OnlineLogReg { constructor(d, lr=0.02, l2=0.001){ this.w=new Array(d).fill(0); this.lr=lr; this.l2=l2; this.prevX=null; this.prevP=null; } static sg(z){ return 1/(1+Math.exp(-Math.max(-50,Math.min(50,z)))) } predict(x){ let z=0; for(let i=0;i<this.w.length;i++) z+=this.w[i]*x[i]; return OnlineLogReg.sg(z); } stepPrepare(x){ const p=this.predict(x); this.prevX=x.slice(); this.prevP=p; return p; } update(y){ if(!this.prevX||this.prevP==null) return; const x=this.prevX, p=this.prevP; const g=p-y; for(let i=0;i<this.w.length;i++){ const grad=g*x[i]+this.l2*this.w[i]; this.w[i]-=this.lr*grad; } this.prevX=null; this.prevP=null; } export(){ return {w:this.w,lr:this.lr,l2:this.l2}; } import(o){ this.w=o.w.slice(); this.lr=o.lr; this.l2=o.l2; this.prevX=null; this.prevP=null; } }
function modelDim(){ return 15; }
function logit(p){ return Math.log(Math.max(1e-9,p)/Math.max(1e-9,1-p)); }
function sigmoid(z){ return 1/(1+Math.exp(-z)); }

/* ===== Tendencia ===== */
function linRegSlope(arr){ const n=arr.length; if(n<2) return 0; const xMean=(n-1)/2; const yMean=arr.reduce((a,b)=>a+b,0)/n; let num=0, den=0; for(let i=0;i<n;i++){ const dx=i-xMean; num+=dx*(arr[i]-yMean); den+=dx*dx; } return den? num/den : 0; }
function trendLabel(arr, W, eps){ const w=Math.min(W,arr.length); if(w<2) return {txt:"‚Äî",slope:0}; const slice=arr.slice(arr.length-w); const slope=linRegSlope(slice); const txt = slope>eps?"Alcista":(slope<-eps?"Bajista":"Lateral"); return {txt,slope}; }

/* ===== Estado ===== */
let DATA=[]; let MODEL=null; let SIGNAL_PENDING=false; let SG_TOTAL=0, SG_WINS=0, SG_LOSS=0; let LAST_SIGNAL_INDEX=-999999;

function ensureModel(){ const lr=parseFloat($("inpLR").value)||0.02; const l2=parseFloat($("inpL2").value)||0.001; if(!MODEL) MODEL=new OnlineLogReg(modelDim(),lr,l2); MODEL.lr=lr; MODEL.l2=l2; }

/* ===== Se√±ales ===== */
function updateSignalCountersOnNewValue(value){ const target=parseFloat($("inpTarget").value)||3; if(SIGNAL_PENDING){ if(value>=target) SG_WINS++; else SG_LOSS++; SIGNAL_PENDING=false; } SG_TOTAL=SG_WINS+SG_LOSS; const acc = SG_TOTAL? (SG_WINS/SG_TOTAL*100).toFixed(1)+"%" : "0.0%"; $("sgPending").textContent=SIGNAL_PENDING?"S√≠":"No"; $("sgTotal").textContent=SG_TOTAL; $("sgWins").textContent=SG_WINS; $("sgLoss").textContent=SG_LOSS; $("sgAcc").textContent=acc; }

/* ===== Stats y gr√°fico ===== */
function renderStats(){ const s=stats(DATA); $("stN").textContent=s.n; $("stMean").textContent=s.mean.toFixed(2)+"√ó"; $("stMed").textContent=s.med.toFixed(2)+"√ó"; $("stP3").textContent=(s.p3*100).toFixed(1)+"%"; $("stP5").textContent=(s.p5*100).toFixed(1)+"%"; $("stMax").textContent=s.max.toFixed(2)+"√ó"; const trW=parseInt($("trW").value||"40",10); const trEps=parseFloat($("trEps").value||"0.01"); const tr=trendLabel(DATA.map(v=>Math.min(v,50)),trW,trEps); $("stTrend").textContent=tr.txt; }
function drawChart(){ const c=$("chart"), ctx=c.getContext("2d"); ctx.clearRect(0,0,c.width,c.height); if(!DATA.length){ ctx.fillStyle="#64748b"; ctx.fillText("Carga datos para ver la serie",10,20); return; } const cap=200, s=clampSeries(DATA,cap); const pad=30,w=c.width-pad*2,h=c.height-pad*2; const max=cap,min=0; ctx.strokeStyle="#13203a"; ctx.beginPath(); ctx.moveTo(pad,c.height-pad); ctx.lineTo(pad,pad); ctx.lineTo(c.width-pad,pad); ctx.stroke(); ctx.strokeStyle="#cbd5e1"; ctx.beginPath(); for(let i=0;i<s.length;i++){ const x=pad+(i/(s.length-1))*w; const y=c.height-pad-((s[i].m-min)/(max-min))*h; if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);} ctx.stroke(); const trW=parseInt($("trW").value||"40",10); const wlen=Math.min(trW,s.length); if(wlen>=2){ const arr=s.slice(s.length-wlen).map(o=>o.m); const xMean=(wlen-1)/2; const yMean=arr.reduce((a,b)=>a+b,0)/wlen; let num=0,den=0; for(let i=0;i<wlen;i++){ const dx=i-xMean; num+=dx*(arr[i]-yMean); den+=dx*dx; } const b=den?num/den:0; const a=yMean-b*xMean; ctx.strokeStyle="#60a5fa"; ctx.beginPath(); for(let i=0;i<wlen;i++){ const xi=s.length-wlen+i; const x=pad+(xi/(s.length-1))*w; const yVal=a+b*i; const y=c.height-pad-((yVal-min)/(max-min))*h; if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);} ctx.stroke(); } const target=parseFloat($("inpTarget").value)||3; const yT=c.height-pad-((target-min)/(max-min))*h; ctx.setLineDash([5,5]); ctx.strokeStyle="#3b82f6"; ctx.beginPath(); ctx.moveTo(pad,yT); ctx.lineTo(c.width-pad,yT); ctx.stroke(); ctx.setLineDash([]); }

/* ===== Decisi√≥n de se√±al ===== */
function updatePredictionUI(pRaw){ const thBase=parseFloat($("inpThresh").value)||0.8; const T=Math.max(0.5, parseFloat($("gateT").value)||1.0); const p=(pRaw==null)? null : sigmoid( logit(pRaw) / T ); if(p==null){ $("prob").textContent="‚Äî"; $("signal").textContent="‚Äî"; $("signal").className="signal no"; $("sgPending").textContent=SIGNAL_PENDING?"S√≠":"No"; return; } $("prob").textContent=p.toFixed(3);
  // Gates
  const cooldown=parseInt($("gateCooldown").value||"0",10); const idx=DATA.length; const cooldownOk=(idx - LAST_SIGNAL_INDEX) >= cooldown;
  const Wlow=parseInt($("gateWlow").value||"20",10); const muMin=parseFloat($("gateMuMin").value)||1.25; const mu=movingMean(DATA,Wlow); const meanOk=(mu===null)?false:(mu>=muMin);
  const K=parseInt($("gateK").value||"8",10); const L=parseFloat($("gateL").value)||1.30; const M=parseInt($("gateM").value||"3",10); const weakCount=countBelow(DATA,K,L); const weakOk=weakCount<=M;
  const trW=parseInt($("trW").value||"40",10); const trEps=parseFloat($("trEps").value||"0.01"); const tr=trendLabel(DATA.map(v=>Math.min(v,50)),trW,trEps); const blockBear=$("gateBlockBear").checked; const bearOk=(!blockBear) || (tr.txt!=="Bajista");
  // Adaptativo
  let th=thBase; if($("gateAdaptive").checked){ const targetAcc=parseFloat($("gateTargetAcc").value)||0.65; const acc=SG_TOTAL? (SG_WINS/SG_TOTAL) : 0.0; if(acc<targetAcc) th=Math.min(0.99, thBase+0.05); else if(acc>targetAcc+0.10) th=Math.max(0.50, thBase-0.02); }
  const passProb = p>=th; const allOk = passProb && cooldownOk && meanOk && weakOk && bearOk;
  if(allOk){ $("signal").textContent=`SE√ëAL (p‚â•${th.toFixed(2)})`; $("signal").className="signal ok"; SIGNAL_PENDING=true; LAST_SIGNAL_INDEX=idx; } else { $("signal").textContent="No se√±al"; $("signal").className="signal no"; }
  $("sgPending").textContent = SIGNAL_PENDING?"S√≠":"No"; }

function movingMean(arr,w){ if(w<=0||arr.length<w) return null; let s=0; for(let i=arr.length-w;i<arr.length;i++) s+=arr[i]; return s/w; }
function countBelow(arr,k,L){ const lastK=arr.slice(Math.max(0,arr.length-k)); return lastK.filter(v=>v<L).length; }

/* ===== Predicci√≥n ===== */
function maybePredictNext(){ const target=parseFloat($("inpTarget").value)||3; const W=parseInt($("inpW").value||"40",10); const minN=parseInt($("inpMinN").value||"10",10); ensureModel(); let p=null; if(DATA.length>=Math.max(5,minN)){ const x=featuresFrom(DATA,W,target); p=MODEL.stepPrepare(x);} updatePredictionUI(p); }

/* ===== Nueva ronda ===== */
function onNewRound(value){ const target=parseFloat($("inpTarget").value)||3; if(MODEL&&MODEL.prevX){ const y=(value>=target)?1:0; MODEL.update(y);} updateSignalCountersOnNewValue(value); DATA.push(value); renderStats(); drawChart(); maybePredictNext(); }

/* ===== Eventos ===== */
$("btnAdd").onclick=()=>{ const v=parseList($("ta").value); if(!v.length) return; v.forEach(onNewRound); $("ta").value=""; };
$("btnClear").onclick=()=>{ DATA=[]; SIGNAL_PENDING=false; SG_TOTAL=SG_WINS=SG_LOSS=0; if(MODEL){ MODEL.prevX=null; MODEL.prevP=null; } renderStats(); drawChart(); updatePredictionUI(null); $("sgPending").textContent="No"; $("sgTotal").textContent="0"; $("sgWins").textContent="0"; $("sgLoss").textContent="0"; $("sgAcc").textContent="0.0%"; };
$("btnQuick").onclick=()=>{ const v=quickNorm($("quick").value); if(v!=null){ onNewRound(v); $("quick").value=""; } };
["inpThresh","gateCooldown","gateWlow","gateMuMin","gateK","gateL","gateM","gateBlockBear","gateT","gateAdaptive","gateTargetAcc","trW","trEps"].forEach(id=>{ const el=$(id); el&&el.addEventListener("input", ()=> updatePredictionUI(MODEL?.prevP ?? null)); });
$("btnReset").onclick=()=>{ MODEL=null; ensureModel(); MODEL.prevX=null; MODEL.prevP=null; maybePredictNext(); };
$("btnExportModel").onclick=()=>{ ensureModel(); const blob=new Blob([JSON.stringify(MODEL.export(),null,2)],{type:"application/json"}); const url=URL.createObjectURL(blob); const a=document.createElement("a"); a.href=url; a.download="learner_model.json"; a.click(); URL.revokeObjectURL(url); };
$("fileModel").onchange=(e)=>{ const f=e.target.files?.[0]; if(!f) return; f.text().then(t=>{ try{ const obj=JSON.parse(t); ensureModel(); MODEL.import(obj); alert("Modelo importado."); maybePredictNext(); }catch(_){ alert("JSON inv√°lido"); } }); };

/* ===== Live OCR (ROI auto + offsets) ===== */
let TESSERACT_WORKER=null; async function ensureTesseract(){ if(TESSERACT_WORKER) return TESSERACT_WORKER; const { createWorker } = await import("https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.esm.min.js"); TESSERACT_WORKER = await createWorker("eng"); return TESSERACT_WORKER; }
function getAutoROI(canvas){ const w=canvas.width, h=canvas.height; const roiW=Math.floor(w*0.4), roiH=Math.floor(h*0.2); let x=Math.floor(w*0.3), y=Math.floor(h*0.4); const offX=parseInt($("roiOffsetX").value||0,10), offY=parseInt($("roiOffsetY").value||0,10); x+=offX; y+=offY; return {x,y,w:roiW,h:roiH}; }
function pxRedRatio(imgData){ const d=imgData.data; let red=0,total=0; for(let i=0;i<d.length;i+=4){ const r=d[i],g=d[i+1],b=d[i+2],a=d[i+3]; if(a<10) continue; if(r>120&&r>g*1.25&&r>b*1.25) red++; total++; } return total? (red/total*100) : 0; }
async function ocrFromROI(){ const c=$("liveCanvas"), {x,y,w,h}=getAutoROI(c); const tmp=document.createElement("canvas"); tmp.width=w; tmp.height=h; const tctx=tmp.getContext("2d"); tctx.drawImage(c,x,y,w,h,0,0,w,h); const worker=await ensureTesseract(); const { data:{ text } } = await worker.recognize(tmp); const raw=(text||"").replace(/,/g,".").toLowerCase(); const m=raw.match(/(\d+(\.\d+)?)/); if(!m) return null; const v=parseFloat(m[1]); if(!isFinite(v)||v<=0||v>10000) return null; return v; }
let LIVE={stream:null,video:null,running:false,redStable:0,lastGrabTs:0};
function liveLog(msg){ const el=$("liveLog"); const li=document.createElement("div"); li.textContent="["+(new Date()).toLocaleTimeString()+"] "+msg; el.prepend(li); }
async function liveLoop(){ if(!LIVE.running) return; const fps=Math.max(1, parseInt($("liveFps").value||"3",10)); const delay=Math.round(1000/fps); const c=$("liveCanvas"), ctx=c.getContext("2d"); const vw=LIVE.video.videoWidth||c.width; const vh=LIVE.video.videoHeight||c.height; if(c.width!==vw||c.height!==vh){ c.width=vw; c.height=vh; } ctx.drawImage(LIVE.video,0,0,c.width,c.height); const roi=getAutoROI(c); ctx.strokeStyle="#60a5fa"; ctx.setLineDash([6,4]); ctx.lineWidth=2; ctx.strokeRect(roi.x,roi.y,roi.w,roi.h); const img=ctx.getImageData(roi.x,roi.y,roi.w,roi.h); const redPct=pxRedRatio(img); const thr=Math.max(1, parseFloat($("redPct").value)||25); const stableN=Math.max(1, parseInt($("stableN").value||"2",10)); const cooldownMs=Math.max(0, parseInt($("liveCooldown").value||"2",10))*1000; const now=performance.now(); if(redPct>=thr){ LIVE.redStable++; if(LIVE.redStable>=stableN && (now - LIVE.lastGrabTs) > cooldownMs){ LIVE.lastGrabTs = now; try{ const val = await ocrFromROI(); if(val!=null){ liveLog(`OCR: ${val.toFixed(2)}√ó (red ${redPct.toFixed(0)}%)`); if($("liveAutoAdd").checked){ onNewRound(val); } } else { liveLog("OCR: sin n√∫mero claro"); } }catch(e){ liveLog("OCR error: "+(e?.message||e)); } LIVE.redStable = 0; } } else { LIVE.redStable = 0; } $("liveInfo").textContent = `Rojo ${redPct.toFixed(1)}% ¬∑ stable ${LIVE.redStable}/${stableN}`; setTimeout(liveLoop, delay); }
$("liveStart").onclick = async()=>{ try{ const fps=Math.max(1, parseInt($("liveFps").value||"3",10)); LIVE.stream = await navigator.mediaDevices.getDisplayMedia({ video:{ frameRate:{ ideal:fps, max:fps } }, audio:false }); LIVE.video = document.createElement("video"); LIVE.video.srcObject = LIVE.stream; await LIVE.video.play(); LIVE.running = true; LIVE.redStable = 0; LIVE.lastGrabTs = 0; $("liveInfo").textContent = "Captura iniciada (ROI auto centro)"; liveLog("Captura iniciada."); liveLoop(); LIVE.stream.getVideoTracks()[0].addEventListener("ended", ()=>{ $("liveStop").click(); }); }catch(e){ liveLog("No se pudo iniciar captura: "+(e?.message||e)); } };
$("liveStop").onclick = ()=>{ LIVE.running = false; try{ LIVE.stream?.getTracks().forEach(t=>t.stop()); }catch(_){} LIVE.stream=null; LIVE.video=null; $("liveInfo").textContent="Sin captura"; liveLog("Captura detenida."); };

/* ===== Init ===== */
function init(){ ensureModel(); renderStats(); drawChart(); updatePredictionUI(null); $("sgPending").textContent="No"; $("sgTotal").textContent="0"; $("sgWins").textContent="0"; $("sgLoss").textContent="0"; $("sgAcc").textContent="0.0%"; }
$("btnReplot").onclick=()=>{ renderStats(); drawChart(); };
init();
</script>
</body>
</html>
