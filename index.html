// ==UserScript==
// @name         Aviator Bot for 1Win with Prediction and Firebase Sync
// @namespace    http://tampermonkey.net/
// @version      1.0
// @description  Legitimate Aviator bot that automates betting, cashes out at fixed multipliers, learns patterns from historical data, predicts signals for >5x, and identifies high multiplier sequences. Uses Firebase for cross-device sync. Adjust DOM selectors as needed for your site.
// @author       Grok
// @match        https://*.1win.com/*aviator*  // Adjust to match your 1Win Aviator page URL
// @match        https://*.1win.partners/*aviator*
// @match        https://*.1wzhzv.top/*aviator*  // Common 1Win variants; add more if needed
// @require      https://www.gstatic.com/firebasejs/10.13.1/firebase-app.js
// @require      https://www.gstatic.com/firebasejs/10.13.1/firebase-database.js
// @require      https://cdn.jsdelivr.net/npm/brain.js@2.0.0-beta/dist/browser.js
// @grant        none
// ==/UserScript==

(function() {
    'use strict';

    // Firebase configuration provided by user
    const firebaseConfig = {
        apiKey: "AIzaSyDuEnNg5XutDF3Ka90o6GFKTazBLR9NnSs",
        authDomain: "aviator-analyzer-b29a7.firebaseapp.com",
        databaseURL: "https://aviator-analyzer-b29a7-default-rtdb.firebaseio.com",
        projectId: "aviator-analyzer-b29a7",
        storageBucket: "aviator-analyzer-b29a7.firebasestorage.app",
        messagingSenderId: "575063626276",
        appId: "1:575063626276:web:5f640e41f0ad791d6a3eb1",
        measurementId: "G-325QCBSQMH"
    };

    // Initialize Firebase
    const app = firebase.initializeApp(firebaseConfig);
    const database = firebase.database(app);
    const crashesRef = database.ref('crashes');  // Stores historical crash multipliers

    // DOM Selectors - Adjust these based on inspecting the 1Win Aviator page (use browser dev tools)
    const multiplierSelector = '.coefficient, .multiplier-value, div[class*="multiplier"]';  // Where current multiplier is displayed (e.g., '1.23x')
    const betAmountInputSelector = 'input.bet-amount, input[class*="bet-input"]';  // Bet amount input field
    const betButtonSelector = '.bet-button, button[class*="place-bet"]';  // Button to place bet
    const cashoutButtonSelector = '.cashout-button, button[class*="cash-out"]';  // Button to cash out
    const gameStatusSelector = '.game-status, div[class*="flew-away"]';  // Element that shows 'Flew away!' or crash message

    // Bot Configuration
    const targetCashout = 5.0;  // Fixed cashout at 5x (can be adjusted)
    const betAmount = 1.0;  // Fixed bet amount (use Martingale or other strategy below)
    const minHistoryForPrediction = 10;  // Minimum crashes needed to train model
    const sequenceThresholds = { high: 10, veryHigh: 100, extreme: 1000 };  // For identifying sequences
    const lookbackForPrediction = 5;  // Use last 5 crashes for input to NN

    // Local state
    let localCrashes = [];
    let isFlying = false;
    let currentMultiplier = 1.0;
    let lastMultiplier = 1.0;
    let net = new brain.NeuralNetwork({ hiddenLayers: [3] });  // Simple NN for prediction
    let isBetPlaced = false;  // Track if bet is placed for current round
    let sequenceCount = { high: 0, veryHigh: 0, extreme: 0 };  // Track consecutive high multipliers

    // Normalize multiplier for NN input (cap at 100x for sanity)
    function normalize(value) {
        return Math.log(value + 1) / Math.log(100 + 1);  // Log scale normalization
    }

    // Load historical crashes from Firebase
    crashesRef.on('value', (snapshot) => {
        const data = snapshot.val();
        localCrashes = data ? Object.values(data) : [];
        console.log(`Loaded ${localCrashes.length} historical crashes from Firebase.`);
        if (localCrashes.length >= minHistoryForPrediction) {
            trainModel();
        }
    });

    // Train the neural network on historical data
    function trainModel() {
        if (localCrashes.length < minHistoryForPrediction + lookbackForPrediction) return;

        const data = [];
        for (let i = lookbackForPrediction; i < localCrashes.length; i++) {
            const input = localCrashes.slice(i - lookbackForPrediction, i).map(normalize);
            const output = [localCrashes[i] > 5 ? 1 : 0];  // Binary: 1 if >5x, 0 otherwise
            data.push({ input, output });
        }

        net.train(data, { iterations: 200, log: true, logPeriod: 50 });
        console.log('Model trained on historical data.');
    }

    // Predict if next round will be >5x
    function predictNext() {
        if (localCrashes.length < lookbackForPrediction) {
            console.log('Not enough data for prediction.');
            return false;
        }

        const input = localCrashes.slice(-lookbackForPrediction).map(normalize);
        const prediction = net.run(input)[0];
        const willBeHigh = prediction > 0.5;
        console.log(`Prediction for next round: ${willBeHigh ? '>5x likely' : '<5x likely'} (confidence: ${prediction})`);
        if (willBeHigh) {
            alert('Signal: Next round predicted to go above 5x! Placing bet.');
        }
        return willBeHigh;
    }

    // Get current multiplier from DOM
    function getCurrentMultiplier() {
        const elem = document.querySelector(multiplierSelector);
        if (elem) {
            const text = elem.textContent.trim().replace('x', '');
            return parseFloat(text);
        }
        return NaN;
    }

    // Check for crash or game status
    function isCrashed() {
        const statusElem = document.querySelector(gameStatusSelector);
        return statusElem && statusElem.textContent.includes('Flew away') || statusElem.textContent.includes('Crash');
    }

    // Place bet automatically
    function placeBet(amount) {
        const input = document.querySelector(betAmountInputSelector);
        if (input) {
            input.value = amount;
            input.dispatchEvent(new Event('input'));
        }
        const button = document.querySelector(betButtonSelector);
        if (button && !button.disabled) {
            button.click();
            isBetPlaced = true;
            console.log(`Bet placed: ${amount}`);
        }
    }

    // Cash out automatically
    function cashOut() {
        const button = document.querySelector(cashoutButtonSelector);
        if (button && !button.disabled) {
            button.click();
            console.log('Cashed out at ' + currentMultiplier + 'x');
            isBetPlaced = false;
        }
    }

    // Identify and alert on high multiplier sequences
    function checkForSequences(multiplier) {
        if (multiplier > sequenceThresholds.extreme) {
            sequenceCount.extreme++;
            alert(`Extreme sequence detected: ${sequenceCount.extreme} consecutive >1000x!`);
        } else if (multiplier > sequenceThresholds.veryHigh) {
            sequenceCount.veryHigh++;
            sequenceCount.extreme = 0;
            alert(`Very high sequence detected: ${sequenceCount.veryHigh} consecutive >100x!`);
        } else if (multiplier > sequenceThresholds.high) {
            sequenceCount.high++;
            sequenceCount.veryHigh = 0;
            sequenceCount.extreme = 0;
            alert(`High sequence detected: ${sequenceCount.high} consecutive >10x!`);
        } else {
            sequenceCount = { high: 0, veryHigh: 0, extreme: 0 };
        }
    }

    // Bankroll management strategy (e.g., simple Martingale)
    let currentBet = betAmount;
    let martingaleMultiplier = 2;  // Double bet after loss
    function adjustBetAfterLoss() {
        currentBet *= martingaleMultiplier;
        console.log(`Martingale: Increasing bet to ${currentBet} after loss.`);
    }
    function resetBetAfterWin() {
        currentBet = betAmount;
        console.log(`Martingale: Resetting bet to ${betAmount} after win.`);
    }

    // Main monitoring loop
    setInterval(() => {
        currentMultiplier = getCurrentMultiplier();

        if (isNaN(currentMultiplier) && isFlying) {
            // Crash detected
            console.log(`Crash at ${lastMultiplier}x`);
            localCrashes.push(lastMultiplier);
            crashesRef.push(lastMultiplier);  // Sync to Firebase
            checkForSequences(lastMultiplier);
            isFlying = false;
            if (isBetPlaced) {
                // If didn't cash out, it's a loss
                adjustBetAfterLoss();
            }
            isBetPlaced = false;
            // Predict for next round
            const shouldBet = predictNext();
            if (shouldBet) {
                placeBet(currentBet);
            }
        } else if (!isNaN(currentMultiplier)) {
            isFlying = true;
            lastMultiplier = currentMultiplier;

            // During flight: check for cashout if bet placed
            if (isBetPlaced && currentMultiplier >= targetCashout) {
                cashOut();
                resetBetAfterWin();
            }

            // Live high multiplier check (for ongoing round)
            if (currentMultiplier > sequenceThresholds.high) {
                console.log(`Live: Multiplier >${sequenceThresholds.high}x - Potential high sequence!`);
            }
        }

        // Additional crash check via status
        if (isCrashed() && isFlying) {
            // Fallback crash detection
            localCrashes.push(lastMultiplier);
            crashesRef.push(lastMultiplier);
            isFlying = false;
        }
    }, 100);  // Poll every 100ms

    console.log('Aviator Bot started. Monitoring game...');
})();
