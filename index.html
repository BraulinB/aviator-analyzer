<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Aviator Analyzer ‚Ä¢ Gocho v12.0 (Rosa 10√ó Sniper PRO)</title>
<style>
  :root{
    --bg:#0f1115; --panel:#171a20; --muted:#98a2b3; --text:#eaeef5;
    --ok:#2ecc71; --warn:#e67e22; --bad:#e74c3c; --brand:#f7a1ff;
  }
  html,body{background:var(--bg);color:var(--text);font:14px/1.45 system-ui,Inter,Segoe UI,Roboto,Arial,sans-serif;margin:0}
  .wrap{max-width:1100px;margin:20px auto;padding:0 12px}
  .card{background:var(--panel);border:1px solid #22283a;border-radius:12px;padding:14px;margin:10px 0}
  h1{font-size:18px;margin:0 0 8px;display:flex;gap:8px;align-items:center}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .btn{background:#2a3042;color:var(--text);border:0;border-radius:8px;padding:8px 12px;cursor:pointer}
  .btn.ok{background:#2ecc71;color:#0c0f12;font-weight:700}
  .muted{color:var(--muted)}
  input[type="text"],select{background:#0f121a;color:var(--text);border:1px solid #2a3144;border-radius:6px;padding:6px}
  input[type="text"]{width:140px}
  .pill{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;background:#1c2130;margin:4px 6px 0 0}
  .pill.small{padding:4px 8px;font-size:12px}
  .table{width:100%;border-collapse:collapse;font-size:13px}
  .table th,.table td{padding:8px;border-bottom:1px solid #22283a;text-align:left}
  .kpi{display:flex;gap:16px;flex-wrap:wrap}
  .kpi .box{background:#0f121a;border:1px solid #22283a;border-radius:10px;padding:10px 12px}
  .clock{font-variant-numeric:tabular-nums}
  .chip{border:1px solid #2a3144;border-radius:8px;padding:4px 8px;margin-right:8px}
  .badge{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid #2a3144;font-weight:600}
  .badge.ok{background:#1f3a2e;color:#7ff5b0;border-color:#275a44}
  .badge.no{background:#3a1f29;color:#ff9b9b;border-color:#5b2a3a}
  .review{white-space:pre-line;font-size:12px;color:#cbd5e1}
  .spark{width:100%;height:90px;display:block}
</style>
</head>
<body>
<div class="wrap">
  <h1>‚úàÔ∏è Aviator Analyzer ‚Ä¢ <span style="color:var(--brand)">Gocho v12.0</span>
    <span class="muted">Rosa 10√ó Sniper PRO</span>
    <span id="statusFeedback" class="muted" style="margin-left:8px"></span>
    <span class="muted" style="margin-left:auto">üïí <b id="clockNow" class="clock">--:--:--</b></span>
  </h1>

  <!-- Controles -->
  <div class="card">
    <div class="row">
      <button id="startBtn" class="btn ok">Iniciar</button>
      <button id="pauseBtn" class="btn">Pausar</button>
      <label class="row"><input id="autoSignal" type="checkbox" checked> Auto‚Äëse√±al</label>
      <label class="row"><input id="beepToggle" type="checkbox" checked> Beep</label>
      <label class="row"><input id="fix1k" type="checkbox" checked> Auto‚Äë1k</label>

      <span class="muted">Agresividad:</span>
      <select id="aggr">
        <option value="EQ" selected>Equilibrado</option>
        <option value="CONS">Conservador</option>
        <option value="AGR">Agresivo</option>
      </select>
      <button id="resetBlockBtn" class="btn">Reiniciar bloque (60)</button>

      <div class="row" style="margin-left:auto">
        <span class="muted">Feed:</span>
        <input id="feedId" type="text" value="gocho"/>
        <button id="connectBtn" class="btn">Conectar</button>
        <button id="disconnectBtn" class="btn">Desconectar</button>
      </div>
    </div>
    <div id="aggrExplain" class="muted" style="margin-top:6px"></div>
  </div>

  <!-- KPIs + Estado de bloque -->
  <div class="card">
    <div class="kpi">
      <div class="box">Rondas: <b id="rounds">0</b> <span class="muted">(base)</span></div>
      <div class="box">MA10: <b id="ma10">‚Äì</b><br><span class="muted">since10:</span> <b id="since10Lbl">‚Äì</b></div>
      <div class="box">Bloque: <b id="blockProg">0/60</b><br><span class="muted">Inicio: <span id="blockStartLbl">‚Äì</span></span></div>
      <div class="box">Plan 10√ó: <b id="planShots">2‚Äì4</b><br><span class="muted">Hechas:</span> <b id="shotsDone">0</b></div>
      <div class="box">Se√±ales: <b id="signals">0</b></div>
      <div class="box">R√©gimen: <b id="regimeLbl">‚Äî</b><br><span class="muted">Calib:</span> <b id="calLbl">bias 0.00 ¬∑ WR ‚Äî</b></div>
    </div>

    <div style="margin-top:8px" id="quotaBox">
      <span class="chip"><b>10√ó</b>: <span id="q10">pend</span></span>
      <span class="chip"><b>L√≠mite</b>: <span id="limitLbl">60</span></span>
      <span class="chip"><b>Sep. m√≠n</b>: <span id="sepLbl">12</span></span>
    </div>

    <div style="margin-top:12px">
      <div class="muted" style="margin-bottom:6px">√öltimas rondas (m√°s reciente primero)</div>
      <div id="lastRounds"></div>
    </div>
  </div>

  <!-- Log -->
  <div class="card">
    <div class="row"><h3 style="margin:0">Se√±ales registradas (solo ROSA 10√ó)</h3></div>
    <table class="table" style="margin-top:8px">
      <thead><tr><th>#</th><th>Tipo</th><th>Objetivo</th><th>Hora</th><th>Stake</th><th>Crash</th><th>Resultado</th><th>P/L</th></tr></thead>
      <tbody id="betsTbody"></tbody>
    </table>
  </div>

  <!-- Diagn√≥stico resumido -->
  <div class="card" id="diagCard">
    <div class="row">
      <h3 style="margin:0">Diagn√≥stico</h3>
      <span class="muted" style="margin-left:auto">Score vs Umbral ¬∑ Hazard relativo ¬∑ Densidad de azules ¬∑ Sequ√≠a 10√ó</span>
    </div>
    <div class="row" style="margin-top:8px">
      <canvas id="chartScore" class="spark" style="flex:1"></canvas>
      <canvas id="chartRel" class="spark" style="flex:1"></canvas>
    </div>
    <div class="row" style="margin-top:8px">
      <canvas id="chartBlue" class="spark" style="flex:1"></canvas>
      <canvas id="chartSince" class="spark" style="flex:1"></canvas>
    </div>
    <div class="muted" id="partsLbl" style="margin-top:6px">‚Äî</div>
  </div>

  <!-- Rese√±as -->
  <div class="card">
    <div class="row"><h3 style="margin:0">An√°lisis & Rese√±as del bloque</h3></div>
    <div id="reviewBox" class="review muted">‚Äî</div>
  </div>

  <div class="card muted" style="font-size:12px">
    Uso educativo/an√°lisis. No garantiza resultados. ‚ÄúGanada‚Äù = crash &gt; objetivo.
  </div>
</div>

<!-- Firebase -->
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>

<script>
/* ======== FIREBASE ======== */
const firebaseConfig = {
  apiKey: "AIzaSyDuEnNg5XutDF3Ka90o6GFKTazBLR9NnSs",
  authDomain: "aviator-analyzer-b29a7.firebaseapp.com",
  projectId: "aviator-analyzer-b29a7",
  storageBucket: "aviator-analyzer-b29a7.appspot.com",
  messagingSenderId: "575063626276",
  appId: "1:575063626276:web:5f640e41f0ad791d6a3eb1",
  measurementId: "G-325QCBSQMH",
  databaseURL: "https://aviator-analyzer-b29a7-default-rtdb.firebaseio.com"
};
firebase.initializeApp(firebaseConfig);
const db  = firebase.database();
const auth= firebase.auth();

/* ======== HELPERS ======== */
const $ = (id)=>document.getElementById(id);
const now=()=>Date.now();
const HHmm = ts => new Date(ts).toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'});
const HHmmss = ts => new Date(ts).toLocaleTimeString([], {hour:'2-digit',minute:'2-digit',second:'2-digit'});
function movingAverage(arr,n){const L=Math.min(arr.length,n); if(!L) return NaN; let s=0; for(let i=arr.length-L;i<arr.length;i++) s+=arr[i]; return s/L;}
function clamp(v,a,b){return v<a?a:(v>b?b:v);}
function lerp(a,b,t){return a+(b-a)*t;}

/* Canvas mini‚Äëgr√°ficas (sin libs) */
function resizeCanvas(c){
  const dpr=window.devicePixelRatio||1; const w=c.clientWidth*dpr,h=c.clientHeight*dpr;
  if(c.width!==w||c.height!==h){c.width=w;c.height=h;}
  return {ctx:c.getContext('2d'),w,h};
}
function drawLine(c, data, opt={}){
  const {ctx,w,h}=resizeCanvas(c), pad=10, W=w-2*pad, H=h-2*pad;
  ctx.clearRect(0,0,w,h);
  const ymin=opt.ymin??Math.min(...data.map(d=>d.v),0), ymax=opt.ymax??Math.max(...data.map(d=>d.v),1);
  ctx.globalAlpha=0.25; ctx.strokeStyle="#2a3144"; for(let k=0;k<=4;k++){const y=pad+H*(k/4);ctx.beginPath();ctx.moveTo(pad,y);ctx.lineTo(pad+W,y);ctx.stroke();}
  ctx.globalAlpha=1; ctx.strokeStyle=opt.color||"#8ab4ff"; ctx.lineWidth=2; ctx.beginPath();
  const N=data.length||1;
  for(let i=0;i<N;i++){ const x=pad+(W*(i))/(N-1||1), y=pad + (1- (clamp(data[i].v,ymin,ymax)-ymin)/(ymax-ymin))*H; if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); }
  ctx.stroke();
  if(opt.ref){ ctx.setLineDash([5,4]); ctx.strokeStyle=opt.ref.color||"#445"; const yr=pad+(1-(clamp(opt.ref.v,ymin,ymax)-ymin)/(ymax-ymin))*H; ctx.beginPath(); ctx.moveTo(pad,yr); ctx.lineTo(pad+W,yr); ctx.stroke(); ctx.setLineDash([]); }
}

/* ======== PARSER crash + Auto‚Äë1k ======== */
function parseCrashValue(raw){
  if(raw===null||raw===undefined) return null;
  if(typeof raw==="number") return (raw>=1 && isFinite(raw))? raw : null;
  let sRaw = String((typeof raw==="object" && raw && ("raw" in raw || "v" in raw)) ? (raw.raw ?? raw.v) : raw);
  const rx=/(\d{1,3}(?:[.,\u00A0\u2009]\d{3})+(?:[.,]\d+)?)/; const m=sRaw.match(rx);
  if(m){
    let t=m[1].replace(/[\u00A0\u2009]/g,' '); const lastDot=t.lastIndexOf('.'), lastComma=t.lastIndexOf(',');
    const dec=(lastComma>lastDot)?',':'.'; if(dec===','){ t=t.replace(/\./g,'').replace(/ /g,'').replace(',', '.'); } else { t=t.replace(/,/g,'').replace(/ /g,''); }
    const v=Number(t); return (isFinite(v)&&v>=1)?v:null;
  }
  let s=sRaw.replace(/[^\d.,+-]+/g,'').trim(); if(!s) return null;
  const lastDot=s.lastIndexOf('.'), lastComma=s.lastIndexOf(','); let dec=(lastComma>lastDot)?',':'.'; if(lastDot===-1&&lastComma===-1) dec='.';
  if(dec===','){ s=s.replace(/\./g,''); s=s.replace(',', '.'); } else { s=s.replace(/,/g,''); }
  let v=Number(s); if(!(isFinite(v)&&v>=1)) return null;
  if($("fix1k")?.checked && v>=300 && v<450){
    const ma10 = movingAverage(rounds,10);
    const recentHuge = rounds.slice(-8).some(x=>x>=200);
    if(recentHuge || (ma10 && ma10>20)) v+=1000;
  }
  return v;
}

/* ======== ESTADO ======== */
const BLOCK_MIN=60, BLOCK_MAX=90, EXT_STEP=10;
let FEED_ID="gocho", connected=false;
let rounds=[], roundsMeta=[], lastShown=[];
let baseCount=0;

let pendings=[], bets=[], signalsCount=0;
const PERSIST_KEY="gocho_v120_sniper_rosa_pro";
const session = {active:false, startTs:null};

const R10=[], I10=[]; let since10=null;

/* ======== CALIBRADOR (umbral adaptativo por resultados) ======== */
const Cal={bias:-0.05, wins:0, total:0, history:[], max:30};
function calUpdateAfterShot(win){
  Cal.history.push(win?1:0); if(Cal.history.length>Cal.max) Cal.history.shift();
  Cal.total++; if(win) Cal.wins++;
  const wr = Cal.history.reduce((a,b)=>a+b,0)/Cal.history.length;
  // objetivo ~0.45 (ajustable). Subimos umbral si va mal; lo bajamos si va demasiado bien.
  const target=0.45, k=0.12;
  Cal.bias += k*(target - wr);
  Cal.bias = clamp(Cal.bias, -0.20, 0.20);
}
function calFalseNegativeNudge(){ Cal.bias = clamp(Cal.bias - 0.03, -0.20, 0.20); }
function calLabel(){
  const wr = Cal.history.length? (Cal.history.reduce((a,b)=>a+b,0)/Cal.history.length) : NaN;
  return `bias ${(Cal.bias>=0?"+":"")}${Cal.bias.toFixed(2)} ¬∑ WR ${isNaN(wr)?"‚Äî":(wr*100).toFixed(0)+"%"}`;
}

/* ======== BLOQUE ======== */
const Block = {
  startIdx:0, limit:BLOCK_MIN,
  minShots:2, maxShots:4, sepAny:12,
  shotsDone:0, lastEmitIdx:-999, ts10:null, reviews:[], extensions:0,
  regime:"normal"
};
function pushReview(txt){ Block.reviews.push(`[${HHmmss(now())}] ${txt}`); $("reviewBox").textContent=Block.reviews.slice(-10).join('\n'); }
function renderPlan(){ $("planShots").textContent=`${Block.minShots}‚Äì${Block.maxShots}`; $("shotsDone").textContent=Block.shotsDone; }
function renderQuota(){ const pos=Math.max(0,rounds.length-Block.startIdx); $("blockProg").textContent=`${clamp(pos,0,Block.limit)}/${Block.limit}`; $("q10").textContent=Block.ts10?("ok @ "+Block.ts10):"pend"; $("limitLbl").textContent=Block.limit; $("sepLbl").textContent=Block.sepAny; }
function resetBlock(){
  Block.startIdx=rounds.length; Block.limit=BLOCK_MIN; Block.shotsDone=0; Block.lastEmitIdx=-999; Block.ts10=null; Block.reviews.length=0; Block.extensions=0;
  Block.regime = detectRegime();
  const plan = planFromRegime(Block.regime);
  Block.minShots=plan.min; Block.maxShots=plan.max; Block.sepAny=plan.sep;
  $("blockStartLbl").textContent=HHmm(now()); renderQuota(); renderPlan();
  pushReview(`Nuevo bloque: r√©gimen ${Block.regime}, plan ${Block.minShots}‚Äì${Block.maxShots}, sep ${Block.sepAny}, l√≠mite ${Block.limit}.`);
}

/* ======== AGRESIVIDAD ======== */
function getAggConf(){
  if(($("aggr")?.value||"EQ")==="CONS"){ return {label:"Conservador", thrMin10:0.88}; }
  if(($("aggr")?.value||"EQ")==="AGR"){  return {label:"Agresivo",   thrMin10:0.80}; }
  return {label:"Equilibrado", thrMin10:0.85};
}
function renderAggExplain(){
  const c=getAggConf();
  $("aggrExplain").textContent=`Modo ${c.label}: sniper ROSA 10√ó con umbral din√°mico + calibrador online. Sin disparos forzados al llegar al l√≠mite; se ampl√≠a a 70/80/90 si es necesario.`;
}

/* ======== M√âTRICAS DE CONTEXTO ======== */
function blueDensity(n=15){const w=rounds.slice(-n); if(!w.length) return 1; return w.filter(x=>x<2).length/w.length;}
function maxBlueRun(n=18){const w=rounds.slice(-n); let m=0,c=0; for(const x of w){ if(x<2){c++; m=Math.max(m,c);} else c=0; } return m;}
function hasPurple(n=12){return rounds.slice(-n).some(x=>x>=5 && x<10);}
function slopeMA10(){ if(rounds.length<11) return 0; const a=movingAverage(rounds,10), b=movingAverage(rounds.slice(0,-1),10); return a-b; }
function count10In(n=60){ const start=Math.max(0,rounds.length-n); let c=0; for(let i=start;i<rounds.length;i++){ if(rounds[i]>=10) c++; } return c; }
function detectRegime(){
  const f=count10In(80)/80; const purpleMany=rounds.slice(-20).filter(x=>x>=5 && x<10).length>=2;
  const sl=slopeMA10(), b25=blueDensity(25);
  if(f>=0.07 || (purpleMany && sl>=0) || (sl>=0.008 && b25<=0.58)) return "hot";
  if(f<=0.03 && b25>=0.60 && sl<=-0.006) return "cold";
  return "normal";
}
function planFromRegime(r){
  if(r==="hot")   return {min:4,max:6,sep: (rounds.length>150?8:10)};
  if(r==="cold")  return {min:2,max:3,sep:14};
  return {min:3,max:5,sep:12};
}

/* ======== HAZARD 10√ó (suavizado con peso a lo reciente) ======== */
function hazardCurve(listIntervals, horizonT){
  const gaps=listIntervals.map(x=>x.gap); const T=Math.max(horizonT,40);
  if(!gaps.length){const hz=Array(T+1).fill(0); for(let t=1;t<=T;t++) hz[t]=1/T; return {hazards:hz, q70:0.01,q75:0.015,q80:0.02,q90:0.03};}
  const maxG=Math.max(...gaps,1), freq=new Map(), alpha=0.07; const N=gaps.length;
  for(let i=0;i<N;i++){ const g=gaps[i], w=Math.pow(1-alpha, N-1-i); freq.set(g,(freq.get(g)||0)+w); }
  let total=0; for(const v of freq.values()) total+=v;
  const pdf=[], cdf=[]; let cum=0; const limit=Math.max(T,maxG+20);
  for(let t=1;t<=limit;t++){ const p=(freq.get(t)||0)/Math.max(total,1); pdf[t]=p; cum+=p; cdf[t]=cum; }
  const hazards=[], vals=[]; for(let t=1;t<=limit;t++){ const S=1-(cdf[t-1]||0); const h=S>0?pdf[t]/S:0; hazards[t]=h; if(h>0) vals.push(h); }
  vals.sort((a,b)=>a-b);
  const pick=p=> vals.length? vals[Math.floor(p*(vals.length-1))] : 0.01;
  return {hazards, q70:pick(0.70), q75:pick(0.75), q80:pick(0.80), q90:pick(0.90)};
}
function qref10(H){ return H.q90; } // m√°s exigente para normalizar rel

/* ======== BOOSTERS DE PATR√ìN (antes de rosas) ======== */
function patternBoost10(){
  const L=rounds;
  const last=(k)=>L.slice(-k);
  let boost=0;
  // p√∫rpura reciente
  if(hasPurple(7)) boost+=0.12;
  // dos verdes >2√ó en √∫ltimas 5
  if(last(5).filter(x=>x>=2 && x<5).length>=2) boost+=0.07;
  // escalera (tres incrementos seguidos en las √∫ltimas 5)
  const a=last(5); let inc=0; for(let i=1;i<a.length;i++){ if(a[i]>a[i-1]) inc++; }
  if(inc>=3) boost+=0.05;
  // fin de racha azul con verde
  if(maxBlueRun(12)>=6 && a[a.length-1]>=2) boost+=0.07;
  // compresi√≥n de varianza (posible breakout)
  const w=last(8); if(w.length>=6){ const mean=w.reduce((s,v)=>s+v,0)/w.length; const varc=w.reduce((s,v)=>s+(v-mean)*(v-mean),0)/w.length; if(varc<0.5 && mean>1.4) boost+=0.05; }
  return clamp(boost,0,0.35);
}

/* ======== GATE (m√°s flexible y dependiente de sequ√≠a/r√©gimen) ======== */
function gateContext10(){
  const b15=blueDensity(15), b25=blueDensity(25), br=maxBlueRun(18), sl=slopeMA10(), s10=since10??0;
  const reg = Block.regime || detectRegime();
  // l√≠mites base por r√©gimen
  let th_b15 = reg==="hot"?0.59: reg==="cold"?0.54:0.56;
  let th_b25 = reg==="hot"?0.62: reg==="cold"?0.57:0.59;
  let th_br  = reg==="hot"?7    : reg==="cold"?5    :6;
  // si hay sequ√≠a fuerte, abre un poco m√°s el gate
  if(s10>=18){ th_b15+=0.02; th_b25+=0.02; th_br+=1; }
  // si tendencia sube, abre; si baja fuerte, cierra
  if(sl>=0.006){ th_b15+=0.01; th_b25+=0.01; }
  if(sl<=-0.008){ th_b15-=0.02; th_b25-=0.02; }
  return (b15<=th_b15) && (b25<=th_b25) && (br<=th_br);
}

/* ======== SCORE ROSA 10√ó ======== */
function rosaScore(){
  const H = hazardCurve(I10, (since10??0) + Block.limit + 20);
  const tNext=(since10??0)+1;
  const hNext=H.hazards[tNext]||0;
  const rel = (qref10(H)>0) ? (hNext/qref10(H)) : 0;

  const s10 = since10 ?? 0;
  const dryness = clamp((s10-18)/18, 0,1);     // arranca antes (m√°s sensible)
  const trend   = slopeMA10();                  // MA10 slope
  const trendSc = clamp((trend+0.015)/0.06, 0,1);
  const blueP   = (()=>{ const b15=blueDensity(15), b25=blueDensity(25), br=maxBlueRun(18);
                         return clamp((b15-0.50)/0.14,0,1)*0.28 + clamp((b25-0.53)/0.14,0,1)*0.22 + (br>=7?0.18:(br>=6?0.08:0)); })();
  const patBoost= patternBoost10();
  const freq10  = count10In(80)/80;
  const freqBias= (freq10>=0.07?0.08:(freq10>=0.05?0.04:0));

  // Puntaje (m√°s agresivo a igualdad de condiciones)
  let base = 0.55*clamp(rel,0,2.5) + 0.23*dryness + 0.16*trendSc + patBoost + freqBias - blueP;
  // ajuste por r√©gimen
  if(Block.regime==="hot") base+=0.04; else if(Block.regime==="cold") base-=0.04;
  // sesgo del calibrador
  base += Cal.bias;

  const score = clamp(base, 0, 1.6);
  return {score, rel, hNext, tNext, s10, parts:{dryness,trendSc,blueP,patBoost,freqBias,rel}, regime:Block.regime};
}

/* ======== SNIPER: decisi√≥n y control de bloque ======== */
function dynamicRosaSniper(){
  if(!session.active) return;
  const pos = rounds.length - Block.startIdx;
  renderQuota();

  // cierre / ampliaci√≥n
  if(pos>=Block.limit){
    if(Block.shotsDone>=Block.minShots){
      pushReview(`Cierra bloque ${Block.limit} | tiros: ${Block.shotsDone}.`);
      resetBlock(); return;
    }else{
      if(Block.extensions<Math.floor((BLOCK_MAX-BLOCK_MIN)/EXT_STEP)){
        Block.limit += EXT_STEP; Block.extensions++;
        pushReview(`Contexto no apto a√∫n. Ampl√≠o margen a ${Block.limit}.`);
        renderQuota();
      }else{
        pushReview(`M√°ximo ${Block.limit} alcanzado sin m√≠nimo de tiros (${Block.minShots}). Cierro sin forzar.`);
        resetBlock();
      }
      return;
    }
  }
  if(Block.shotsDone>=Block.maxShots) return;

  // separaci√≥n m√≠nima
  const sepOk = (rounds.length - Block.lastEmitIdx) >= Block.sepAny;

  // score y umbral
  const S = rosaScore();
  const cfg=getAggConf();
  const prog = clamp(pos/Block.limit, 0, 1);
  // umbral base baja m√°s en caliente
  let thrNow = lerp(1.00, cfg.thrMin10, prog);
  if(Block.regime==="hot") thrNow -= 0.06;
  if(Block.regime==="cold") thrNow += 0.04;
  thrNow = clamp(thrNow, 0.70, 1.15);

  // gate
  const gateOK = gateContext10();

  // Edge‚Äëshot: sequ√≠a alta o patr√≥n fuerte, a√∫n si gate cierra por azules
  const edgeOK = ( (S.parts.dryness>=0.8 && S.rel>=0.85) || (S.parts.patBoost>=0.16 && S.rel>=0.8) );

  // Disparo
  if(sepOk && ( (gateOK && S.score>=thrNow) || (edgeOK && S.score>=thrNow-0.05) )){
    emitShot10("SNIPER_ROSA_10x", S, thrNow);
    Block.ts10 = HHmmss(now());
    Block.lastEmitIdx = rounds.length;
    Block.shotsDone++;
    renderPlan(); renderQuota();
  }else{
    // rese√±as ligeras cada 12 rondas
    if(pos % 12 === 0){
      const why = !sepOk ? `sep ${rounds.length-Block.lastEmitIdx}/${Block.sepAny}`
                : !gateOK ? `gate cerrado`
                : `score ${S.score.toFixed(2)} < umbral ${thrNow.toFixed(2)}`;
      pushReview(`No tiro: ${why} | reg ${Block.regime}, rel ${S.rel.toFixed(2)}, s10 ${S.s10}`);
    }
  }

  // diagnostico mini‚Äëcharts
  diagPush(S, thrNow);
}

/* ======== EMISI√ìN Y RESOLUCI√ìN ======== */
function emitShot10(tag, S, thrNow){
  if(!$("autoSignal").checked) return;
  const id="S"+now(); const ts=now();
  pendings.push({id,target:10,stake:1,ts,emittedAt:HHmmss(ts),state:"pend",tag,reason:"rosa10",conf:clamp(S.score,0,1)});
  signalsCount++; $("signals").textContent=signalsCount;
  pushReview(`üî• Disparo 10√ó (reg ${Block.regime}) | score ${S.score.toFixed(2)} vs thr ${thrNow.toFixed(2)} | rel ${S.rel.toFixed(2)} | s10 ${S.s10}`);
  beep(360,150,0.04); setTimeout(()=>beep(980,100,0.035),200);
  renderBets();
}
function onBetResolved(win){
  calUpdateAfterShot(win);
  $("calLbl").textContent = calLabel();
}

/* ======== RENDER ======== */
function renderStats(){
  $("rounds").textContent = `${rounds.length} (base ${baseCount})`;
  const ma10=movingAverage(rounds,10); $("ma10").textContent=isNaN(ma10)?"‚Äì":ma10.toFixed(2)+"x";
  $("since10Lbl").textContent= since10==null?"‚Äì":since10;
  $("regimeLbl").textContent = Block.regime;
  $("calLbl").textContent = calLabel();
  const cont=$("lastRounds"); cont.innerHTML="";
  lastShown.forEach(x=>{ const d=document.createElement("span"); d.className="pill small"; d.textContent=x.toFixed(2)+"x"; cont.appendChild(d); });
  renderQuota();
}
function renderBets(){
  const tb=$("betsTbody"); tb.innerHTML="";
  bets.concat(pendings).forEach((b,i)=>{
    const st=b.state==="win"?"win":b.state==="lose"?"lose":"pend";
    const tr=document.createElement("tr");
    tr.innerHTML=`<td>${i+1}</td><td>${b.tag||"ROSA_10x"}</td><td>${b.target}x</td><td>${b.emittedAt||"‚Äî"}</td><td>$${(b.stake?.toFixed?b.stake.toFixed(2):b.stake)||"1.00"}</td><td>${b.crash?b.crash.toFixed(2)+"x":"‚Äî"}</td><td>${st}</td><td>${b.pl||"‚Äî"}</td>`;
    tb.appendChild(tr);
  });
}

/* ======== DIAGN√ìSTICO (series) ======== */
const Diag = {max:120, score:[], thr:[], rel:[], b15:[], b25:[], s10:[]};
function diagPush(S, thr){
  const b15=blueDensity(15), b25=blueDensity(25);
  const push=(a,v)=>{a.push(v); if(a.length>Diag.max) a.shift();};
  push(Diag.score, clamp(S.score,0,1.6));
  push(Diag.thr,   thr);
  push(Diag.rel,   clamp(S.rel,0,2.2));
  push(Diag.b15,   b15);
  push(Diag.b25,   b25);
  push(Diag.s10,   S.s10);
  drawLine($("chartScore"), Diag.score.map(v=>({v})), {ymin:0,ymax:1.6,ref:{v:Diag.thr[Diag.thr.length-1]||1.0,color:"#8ab4ff"} ,color:"#f7a1ff"});
  drawLine($("chartRel"),   Diag.rel.map(v=>({v})),   {ymin:0,ymax:2.2,ref:{v:1.0,color:"#888"} ,color:"#ffd166"});
  drawLine($("chartBlue"),  Diag.b15.map(v=>({v})),   {ymin:0.3,ymax:0.8,ref:{v:0.56,color:"#555"} ,color:"#9fb8ff"});
  drawLine($("chartSince"), Diag.s10.map(v=>({v})),   {ymin:0,ymax:60,color:"#a3f7c1"});
  $("partsLbl").textContent = `parts ‚Äî rel:${S.parts.rel.toFixed(2)} | dry:${S.parts.dryness.toFixed(2)} | trend:${S.parts.trendSc.toFixed(2)} | pat:${S.parts.patBoost.toFixed(2)} | blueP:${S.parts.blueP.toFixed(2)} | freqB:${S.parts.freqBias.toFixed(2)} | regime:${S.regime}`;
}

/* ======== EVENTOS por ronda ======== */
function pushEvt10(v,ts){
  if(v>=10){
    const idx=rounds.length-1, ev={idx,v,ts}; R10.push(ev);
    if(R10.length>=2){
      const prev=R10[R10.length-2]; I10.push({from:prev,to:ev,gap:ev.idx-prev.idx}); if(I10.length>240) I10.shift();
    }
    since10=0;
  }else{
    since10=(since10==null?1:since10+1);
  }
}
function onNewCrash(v, ts, base=false){
  rounds.push(v); roundsMeta.push({v,ts}); if(rounds.length>3000){rounds.shift(); roundsMeta.shift();}
  lastShown.unshift(v); if(lastShown.length>60) lastShown.pop();

  // resolver pendientes (solo 10√ó)
  if(!base && pendings.length && session.active){
    const bet=pendings.shift(); const win=(v>bet.target);
    bet.crash=v; bet.state=win?"win":"lose"; bet.pl=win?"+1":"‚àí1";
    bets.push(bet); if(bets.length>800) bets.splice(0,bets.length-800);
    renderBets(); onBetResolved(win);
  }else if(!session.active){ pendings=[]; }

  // falsos negativos: si aparece >=10√ó y no hubo tiro en √∫ltimas 4, bajamos umbral un poco
  if(!base && v>=10 && session.active && ((rounds.length - Block.lastEmitIdx)>4)){ calFalseNegativeNudge(); $("calLbl").textContent = calLabel(); pushReview("Ajuste por falso negativo: bajo umbral ligeramente."); }

  pushEvt10(v,ts);

  // actualizar r√©gimen din√°mico cada 20 rondas
  if(rounds.length%20===0){ const newReg=detectRegime(); if(newReg!==Block.regime){ Block.regime=newReg; const plan=planFromRegime(Block.regime); Block.minShots=plan.min; Block.maxShots=plan.max; Block.sepAny=plan.sep; pushReview(`Cambia r√©gimen a ${Block.regime}. Nuevo plan ${Block.minShots}‚Äì${Block.maxShots}, sep ${Block.sepAny}.`);} }

  renderStats();
  if(!base){ dynamicRosaSniper(); }
}

/* ======== CONEXI√ìN FEED ======== */
let liveRef=null, liveCb=null, lastKey=null, lastTs=null, lastActivity=null, watchdog=null;
function nodeToVT(node){ const raw=(node&&typeof node==='object'&&('raw'in node||'v'in node))?(node.raw??node.v):node; const v=parseCrashValue(raw); const ts=Number(node?.ts)||now(); return {v,ts}; }
async function connectFeed(){
  if(connected) return;
  FEED_ID=($("feedId").value||"gocho").trim();
  const fb=$("statusFeedback"); fb&&(fb.textContent=`Conectando a feeds/${FEED_ID}/crashes‚Ä¶`);
  try{ await auth.signInAnonymously(); }catch(e){}
  const ref=db.ref(`feeds/${FEED_ID}/crashes`);
  fb&&(fb.textContent="Cargando historial‚Ä¶");
  let snap=null, method="key";
  try{ const s=await ref.orderByChild("ts").limitToLast(800).once("value"); if(s && s.val()) { snap=s; method="ts"; } }catch(e){}
  if(!snap){ try{ const s=await ref.orderByKey().limitToLast(800).once("value"); if(s && s.val()) { snap=s; method="key"; } }catch(e){} }
  if(!snap||!snap.val()){ fb&&(fb.textContent="Sin datos en el feed."); return; }

  rounds=[]; roundsMeta=[]; lastShown=[]; [R10].forEach(a=>a.length=0); [I10].forEach(a=>a.length=0);
  since10=null; baseCount=Object.keys(snap.val()).length;

  const data=snap.val(), keys=Object.keys(data).sort();
  keys.forEach(k=>{ const {v,ts}=nodeToVT(data[k]); if(v!==null) onNewCrash(v,ts,true); lastKey=k; lastTs=Number(data[k]?.ts||k)||now(); lastActivity=now(); });

  Block.regime=detectRegime(); renderAggExplain(); resetBlock(); renderStats();

  if(method==="ts"){
    liveRef=ref.orderByChild("ts").startAt(lastTs);
    liveCb=s=>{ const key=s.key, d=s.val(); const {v,ts}=nodeToVT(d); if(lastTs && ts<=lastTs && key===lastKey) return; lastKey=key; lastTs=ts; lastActivity=now(); if(v!==null) onNewCrash(v,ts,false); };
  }else{
    liveRef=ref.orderByKey().startAt(lastKey||"");
    liveCb=s=>{ const key=s.key, d=s.val(); if(lastKey && key<=lastKey) return; lastKey=key; const {v,ts}=nodeToVT(d); lastTs=ts; lastActivity=now(); if(v!==null) onNewCrash(v,ts,false); };
  }
  liveRef.on("child_added", liveCb);

  if(watchdog) clearInterval(watchdog);
  watchdog=setInterval(()=>{ if(!connected) return; const dt=Date.now()-(lastActivity||0); if(dt>300000){ disconnectFeed(true); connectFeed(); } }, 30000);

  connected=true; fb&&(fb.textContent="Conectado.");
}
function disconnectFeed(silent=false){
  if(!connected) return;
  if(liveRef && liveCb) liveRef.off("child_added", liveCb);
  liveRef=liveCb=null; lastKey=lastTs=lastActivity=null; connected=false;
  if(watchdog){ clearInterval(watchdog); watchdog=null; }
  if(!silent){ const fb=$("statusFeedback"); fb&&(fb.textContent="Desconectado."); }
}

/* ======== PERSISTENCIA ======== */
function persistLocal(){
  try{
    localStorage.setItem(PERSIST_KEY, JSON.stringify({
      bets, pendings, signalsCount, session,
      block:{startIdx:Block.startIdx, limit:Block.limit, minShots:Block.minShots, maxShots:Block.maxShots, sepAny:Block.sepAny, shotsDone:Block.shotsDone, lastEmitIdx:Block.lastEmitIdx, ts10:Block.ts10, reviews:Block.reviews, extensions:Block.extensions, regime:Block.regime},
      aggr:$("aggr").value, cal:Cal
    }));
  }catch(_){}
}
function restoreLocal(){
  try{
    const raw=localStorage.getItem(PERSIST_KEY); if(!raw) return;
    const p=JSON.parse(raw);
    if(Array.isArray(p.bets)) bets=p.bets;
    if(Array.isArray(p.pendings)) pendings=p.pendings;
    if(typeof p.signalsCount==="number") signalsCount=p.signalsCount;
    if(p.session && typeof p.session.active==="boolean"){ session.active=p.session.active; session.startTs=p.session.startTs||null; }
    if(p.block){
      Block.startIdx=p.block.startIdx||0; Block.limit=p.block.limit||BLOCK_MIN; Block.minShots=p.block.minShots||2; Block.maxShots=p.block.maxShots||4; Block.sepAny=p.block.sepAny||12; Block.shotsDone=p.block.shotsDone||0; Block.lastEmitIdx=p.block.lastEmitIdx||-999; Block.ts10=p.block.ts10||null; Block.reviews=Array.isArray(p.block.reviews)?p.block.reviews:[]; Block.extensions=p.block.extensions||0; Block.regime=p.block.regime||"normal";
    }
    if(p.aggr) $("aggr").value=p.aggr;
    if(p.cal){ Object.assign(Cal,p.cal); }
  }catch(_){}
}

/* ======== UI ======== */
$("connectBtn").addEventListener("click", connectFeed);
$("disconnectBtn").addEventListener("click", ()=>disconnectFeed(false));
$("startBtn").addEventListener("click", ()=>{
  session.active=true; session.startTs=now();
  bets=[]; pendings=[]; signalsCount=0;
  Cal.bias=-0.05; Cal.history=[]; Cal.total=0; Cal.wins=0;
  resetBlock(); renderBets(); renderStats();
  $("calLbl").textContent = calLabel();
  // prime diagn√≥stico
  diagPush(rosaScore(), 1.0);
});
$("pauseBtn").addEventListener("click",  ()=>{ session.active=false; });
$("aggr").addEventListener("change", ()=>{ renderAggExplain(); });
$("resetBlockBtn").addEventListener("click", ()=>{ resetBlock(); });

setInterval(()=>{ $("clockNow").textContent=new Date().toLocaleTimeString(); persistLocal(); }, 1000);

/* ======== BOOT ======== */
(function(){
  restoreLocal(); renderBets(); renderStats(); renderAggExplain();
})();
</script>
</body>
</html>
